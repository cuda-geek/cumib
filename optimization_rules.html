<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>cumib by cuda-geek</title>
    <meta name="description" content="cuda.geek's personal blog about architectures and optimization them.">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="stylesheets/normalize.css">
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="3dparty/reveal/lib/css/zenburn.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="3dparty/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <div id="header">
      <div id="title">
        <h1>cumib</h1>
        <p>The CUDA microbenchmarks</p>
      </div>
    </div>

    <div class="wrapper">
      <section>
        <h1>Essential Optimization Rules</h1>
        <p>What does it mean to be pragmatic optimizer? Here is a simple, but essential set of rules that are aimed to help
        you to do your optimization work optimally. </p>
        <h2>1. Say NO to premature optimization</h2>
        <p>I know, this rule is rather well known. Many books about programming subject explains this aspect. However,
        I feel I need to cover it here from pragmatic point of view.</p>
        <p>Imagine, you develop some cutting age algorithm which
        is not well defined and requires some experimental work to be done. During all development process you thinking
        about doing it optimal and truing to do you best to ensure good performance. There are several concerns about
        this approach</p>
        <ul>
          <li>Most part of your code would be done to be thrown into trash bin. As I mentioned the algorithm is experimental so
          nobody guarantees that the approach and consequently code will not be completely reworked after several experiments.
          You would be disappointed, if all your good works was thrown out together with the failed approach. Are not you?</li>
          <li>You would not see the complete picture of the algorithm. For example, If you done some data restructuring
          to optimize one piece of code It could add significant overhead to other part of the pipeline in future because
          it was not considered during the optimization</li>
        </ul>
        <p>This is only some items from a long list of problems stemming from premature optimization. So be careful with it.</p>
        <h2>2. Time and profile, then optimize</h2>
        <p>Be aware of current function runtime. Newer start optimization before timings are done. Do not start optimization
        from function that you suspect to be a bottleneck. You always need a proof.</p>
        <h2>3. Optimize the most consuming function first</h2>
        <p>Be objective. Do not choose the easiest, the funniest, the first called and so on. Keep in mind that 80% of time
        is spend in 20% of code. </p>
        <h2>4. Identify performance limiters</h2>
        <p>What limits performance of optimizing function? Is it a number of memory transactions? Is it a critical path is
        arithmetic? Is it Lack of computational resources of particular type? Depending on kind of limiters your optimization
        strategy will vary. If you do not do this you will spend ages overcoming problem that is not present.</p>
        <h2>5. Compute only what is necessary</h2>
        <p>Empty function body is extremely fast, but does nothing useful. First off all understand the optimizing function
        and define the set of required operations. Get rid of everything except this set.</p>
        <h2>6. Load only what is necessary</h2>
        <p>It is well known that most codes are memory bound. Many thins done to improve memory performance like multilevel
        cache hierarchies, white back and everything. But processor performance is still be a bit ahead. You should be
        aware about memory organization of the system you currently targeting. In more important, you should well understand
        function you currently optimize to minimize its memory footprint there it is possible. If so you would not spend time
        to transfer useless bytes through whole memory subsystem.</p>
        <h2>7. Understand the reason of speedup</h2>
        <p>It is cool that you got some speed up. Ask yourself: Are you sure about its reasons? Have you eliminated pipeline
        stalls? Have you reused data in caches more effectively? This understanding will be extremely helpful to generalize
        your knowledge and reuse approaches in future. This function is not going to be last code you optimize, right? </p>
        <h2>8. Keep it simple</h2>
        <p>Optimization is always a tread off between code simplicity and peak performance. You always should consider that
        fact while submitting new optimizations. To be honest, I love all this geeky stuff very much. I mean writing assembly,
        peephole optimization. last 10% of runtime are cut out from that kind of thing in most cases.</p>
        <p>And finally, just think think about the guy who will own your code after you.</p>
        <h2>9. Check one approach in time</h2>
        <p>Do not try to apply all you ideas in once.</p>
        <hr>
        <span class="credits left">Project maintained by <a href="https://github.com/cuda-geek">cuda-geek</a></span>
        <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
      </section>
    </div>
  </body>
</html>