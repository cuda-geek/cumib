<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>cumib by cuda-geek</title>
    <meta name="description" content="cuda.geek's personal blog about architectures and optimization them.">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="stylesheets/normalize.css">
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="3dparty/reveal/lib/css/zenburn.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="3dparty/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <div id="header">
      <div id="title">
        <h1>cumib</h1>
        <p>The CUDA microbenchmarks</p>
      </div>
    </div>

    <div class="wrapper">
      <section>
        <h1>Essential Optimization Rules</h1>
        <p><b>What does it mean "to be a pragmatic optimizer"?</b> As for me, a pragmatic optimizer is someone
        who is objective, specific and certain about the things that he/she does to make software run faster.
        I decided to express the idea of pragmatic optimization in several pieces of advice. This is a simple,
        but essential set that is aimed to help you to do your optimization work <b>optimally</b>.</p>

        <h2 style="color: #6F3;">1. Say NO to premature optimization</h2>
        <p>Yes, I know, this rule is rather well known. Many books about programming explain this aspect.
        However, I feel, I need to consider it from a pragmatic point of view.</p>
        <p>Imagine, you develop some cutting edge algorithm. This algorithm is not well defined and requires
        experimental work. You think about doing it optimally and trying to do your best to ensure good performance
        during all development process. But look, there are several concerns about this approach:</p>
        <ul>
          <li><b>Most part of your optimal code would be done to be thrown out into a trash bin.</b> As I mentioned,
          the algorithm is experimental so nobody can guarantee that the approach and code consequently
          will not have to be completely rewritten after several experiments. You will be disappointed
          if all your work is thrown out together with the failed approach. Won't you?</li>
          <li><b>You won't see a full picture of the algorithm if it is incomplete.</b> For example,
          if you have done some data restructuring which optimizes one piece of the code it could add
          significant overhead to other parts of the pipeline in future because it was not considered
          during the optimization.</li>
        </ul>
        <p>This is only some items from a long list of problems stemming from premature optimization. So be careful.
        Don't get me wrong, but I'm not trying to dissuade you deal with your work.
        I urge you to choose the right moment for this.</p>

        <h2 style="color: #6F3;">2. Time and profile, then optimize</h2>
        <p>Consider pipeline runtime. Never start optimization if timings are not done. Do not start optimization
        with a function, that you suspect to be a bottleneck. You need a proof! <b>Blind</b> optimization is not better
        than premature. In general, it results in the same problems. If your guess is wrong, you will spend time
        without any improvement. If your guess is right, you are lucky. It is pointless to rely just on luck
        when it comes to the fate of your project. Right?</p>

        <h2 style="color: #6F3;">3. Optimize the most consuming function first</h2>
        <p>This is closely connected with the previous one. Sometimes, even if someone has an application profile,
        it is not considered. <b>Be objective.</b> Do not choose the easiest, the funniest, or just the first thing
        on the profile list and so on. <b>Bear in mind that 80% of the time is spent on 20% of the code.</b>.
        You ought to find these 20%.</p>
        <p>In most cases, it is simple to follow this rule. Just collect your profile, find a bottleneck,
        optimize it and move on to the the newly appeared.</p>

        <h2 style="color: #6F3;">4. Identify performance limiters</h2>
        <p>What limits performance of your function? Is it a number of memory transactions? Is it
        a critical path in arithmetic? Is it a lack of computational resources of a particular type? Depending
        on a kind of limiters your optimization strategy will vary. If you don't identify limiters, you will spend
        ages on a problem that does not exists.</p>
        <ul>
          <li><b>Learn the architecture in a very detail.</b> Comprehensive knowledge will help you build a chain
          of cause-effect relationships and be more precise about strengths as well as limits of the hardware
          and compilers.</li>
          <li><b>Demystify profiling tools and disassembly.</b> I am pretty sure that optimization without looking into
          disassembly is impossible. Look into it to check that compiler did his job well. Look into it to check that
          you did not get extra operations like spills on stack.</li>
        </ul>

        <h2 style="color: #6F3;">5. Compute only what is necessary</h2>
        <p>Obviously, an empty function is extremely fast, but the problem is that it does nothing useful. First of all,
        you should understand the function and define the set of required operations. Get rid of everything
        except this set. A large proportion of the acceleration is done exactly this way.</p>

        <h2 style="color: #6F3;">6. Load only what is necessary</h2>
        <p>It is well known that most codes are memory bound. Many thins are done to improve memory performance
        like multilevel cache hierarchies, white back and everything. But processor performance is still a bit ahead.
        You should be aware of memory organization of the system you currently targeting. Moreover,
        you should understand the function you are currently optimizing well to minimize its memory footprint
        there it is possible. If so, you would not spend time to transfer useless bytes through the whole
        memory subsystem.</p>
        <p>Another aspect is choosing proper data types and data structures.</p>

        <h2 style="color: #6F3;">7. Understand the reason of speedup</h2>
        <p>It is cool that you got some speed up. Ask yourself: are you sure about its reasons? Have you eliminated
        pipeline stalls? Have you reused data in caches more effectively? This understanding will be extremely helpful
        to generalize your knowledge and reuse approaches in future. This function is not going to be the last code
        you optimize, right?</p>

        <h2 style="color: #6F3;">8. Keep it simple</h2>
        <p>Optimization is always a tread off between code simplicity and peak performance. You always should consider
        that fact while submitting new optimizations. To be honest, I love all this geeky stuff very much.
        I mean, writing assembly, peephole optimization. Last 10% of runtime are cut out from that kind of thing
        in most cases.</p>
        <p>And finally, just think about a guy who will own your code after you.</p>

        <h2>9. Check one approach at a time</h2>
        <p>Do not try to apply all your ideas in once.</p>

        <h2>10. Use scientific approach</h2>
        <p>Think about profiling and optimization like about scientific experiment. <!--Setup--> </p>

        <h2>11. Avoid SIMDization</h2>
        <p></p>
        <hr>
        <p>And the last thing, you will have lots of fun if you are a detective in this story of optimization.</p>
        <hr>
        <span class="credits left">Project maintained by <a href="https://github.com/cuda-geek">cuda-geek</a></span>
        <span class="credits right">Hosted on GitHub Pages &mdash; Theme by
          <a href="https://twitter.com/michigangraham">mattgraham</a>
        </span>
      </section>
    </div>
  </body>
</html>
