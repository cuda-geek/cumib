<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Pragmatic optimization in modern programming</title>
    <meta name="description" content="Pragmatic optimization in modern programming - Introduction">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="plugin/reveal/css/reveal.css">
    <link rel="stylesheet" href="plugin/reveal/css/theme/geek.css" id="theme">
    <link rel="stylesheet" href="css/colors-orange.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="plugin/reveal/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'plugin/reveal/css/print/pdf.css' : 'plugin/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="plugin/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <h1>Pragmatic optimization</h1>
          <h2>in modern programming</h2>
          <h3>Ordering approaches</h3>
          <br>
          <br>
          <br>
          <small>Created by
            <a href="http://github.com/cuda-geek">Marina Kolpakova</a>
            for
            <a href="http://www.unn.ru/eng/">UNN</a>
          </small>
        </section>

        <section>
          <h2>Outline</h2>
          <ul>
            <li>What is optimization?</li>
            <li>Towards pragmatic approach</li>
            <li>Place of optimization in a project live cycle</li>
            <li>Ordering optimizations</li>
            <li>Optimization steps
              <ul>
                <li>which we'll discuss in details during the course</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2>What is optimization?</h2>
          <blockquote>In computing, <b>optimization</b> is the process of modifying a system to make some aspect of it
          work more efficiently or use fewer resources.
          <br/>
          In particular, this is a process of transforming a piece of code
          to make it <b>more efficient without changing its output</b>.</blockquote>
          <!--refactoring that makes you code run faster-->
          <p>Metrics are commonly considered:</p>
          <dl>
            <dt ><b>Wall-clock time, or wall time</b></dt>
            <dd style="margin-left: 5em;">
              <strong>is the human perception of the passage of time from the start to the completion of a task.</strong>
            </dd>
            <dt><b>Power consumption</b></dt>
            <dd style="margin-left: 5em;">is the electrical energy over time which is supplied to complete task.</dd>
            <dt><b>CPU time, or processor time</b></dt>
            <dd style="margin-left: 5em;">is the total execution time or runtime for which the CPU (or other computing
            device) was dedicated to a task (used for processing instructions of that task)</dd>
          </dl>
        </section>

        <section>
          <h2>Pragmatic approach</h2>
          <blockquote>
          &ldquo;Programmers waste enormous amounts of time thinking about, or worrying about, the speed of non-critical
          parts of their programs, and these attempts at efficiency actually have a strong negative impact when
          debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time;
          <b>premature optimization is the root of all evil</b>. Yet we should not pass up our opportunities in
          that critical 3%.&ldquo;
            <div style="text-align:right;">
              <br/>
              <small>-Donald Knuth, Structured Programming With go to Statements</small>
            </div>
          </blockquote>
        </section>

<!--           <section>
          <h2>where to get performance?</h2>
          <table>
            <thead>
              <tr>
                <th>Software</th>
                <th>Hardware</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>hi</td>
                <td>higher clocks</td>
              </tr>
              <tr>
                <td>Lemonade</td>
                <td>Sophisticated pipelines</td>
              </tr>
              <tr>
                <td>Bread</td>
                <td>Deep memory hierarchies</td>
              </tr>
              <tr>
                <td>Apples</td>
                <td>SIMD extensions</td>
              </tr>
              <tr>
                <td>Task parallelization</td>
                <td>Multi-core</td>
              </tr>
            </tbody>
          </table>

          <ul>
            <li>Software
              <ul>
                <li>mow level programming tricks</li>
              </ul>
            </li>
            <li>Hardware
              <ul>
                <li>Sophisticated pipelines</li>
              </ul>
            </li>
            <li>Software</li>
          </ul>
        </section> -->

        <section>
          <h2>Knowledge is required</h2>
          <ol>
            <li><b>The code</b>
              <ul>
                <li>The problem, it solves</li>
                <li>The algorithm, it implements</li>
                <li>Complexity of the algorithm</li>
              </ul>
            </li>
            <li><b>The compiler</b>
              <ul>
                <li>Compilation trajectory</li>
                <li>Compiler's optimization capabilities and obstacles</li>
              </ul>
            </li>
            <li><b>The platform</b>
              <ul>
                <li>Architecture capabilities
                  <ul>I<small style="vertical-align: bottom">nstruction</small>
                      S<small style="vertical-align: bottom">set</small>
                      A<small style="vertical-align: bottom">rchitecture</small></ul>
                </li>
                <li>Micro-architecture specifics</li>
              </ul>
            </li>
          </ol>
        </section>

        <section>
          <h2>Project life cycle</h2>
          <img class="simple" src="images/popt/pdl.png"/>
        </section>

        <section>
          <h2>Project optimization cycle</h2>
          <img src="images/popt/opt_cycle.jpg"/>
        </section>

        <section>
          <h2>Top-Down (High-low) approach</h2>
          <ol style="width:40%;">
            <li><h4>Use appropriate algorithm</h4></li>
            <br/>
            <li><h4>Optimize memory access patterns</h4></li>
            <li><h4>Minimize the number of operations</h4></li>
            <br/>
            <li><h4>Shrink the critical path</h4></li>
            <li><h4>Perform hardware specific optimizations</h4></li>
            <li><h4>Dive into assembly</h4></li>
          </ol>
        </section>

        <section>
          <h2>From whence get performance?</h2>
          <dl>
            <dt><b>Algorithm</b></dt>
            <dd>
              <ul>
                <li>decreasing big-O complexity,</li>
                <li>using optimized libraries for sub-routines,</li>
                <li>restructuring the code,</li>
                <li>parallelization.</li>
              </ul>
            </dd>
            <dt><b>Memory access patterns &amp; operations</b></dt>
            <dd>
              <ul>
                <li>usage of optimizing compilers, auto-vectorization</li>
                <li>loop optimizations, vectorization.</li>
              </ul>
            </dd>
            <dt><b>Shrinking critical path &amp; performing HW specific optimizations</b></dt>
            <dd>fine-grained optimizations</dd>
          </dl>
        </section>

        <section>
          <h2>Tread-offs</h2>
          <ul>
            <li>Code portability decreases when we go deeper</li>
            <li>Performance portability decreases when we go deeper</li>
            <li>The cost of maintenance &amp; extendability increases when we go deeper</li>
            <li>Optimizations are often not reusable</li>
            <li>Optimizations become obsolete very quickly</li>
          </ul>
          <br/>
          <strong>...but still for most applications performance is a crucial requirement.</strong>
        </section>

        <section>
          <h2>Understand the code</h2>
          <ul>
            <li>Different people think differently
              <ul>
                <li>you'll need time to get used to the code</li>
              </ul>
            </li>
            <li>Understand dataflow
              <ul>
                <li>input parameters</li>
                <li>output results</li>
                <li>data dependencies</li>
              </ul>
            </li>
            <li><b>Identify performance limiters</b>
              <ul>
                <li>Time</li>
                <li>Profile</li>
                <li>Grub metrics
                  <ul>
                    <li>eg power consumption</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Use appropriate algorithm</h2>
            <p>Consider:</p>
            <ul>
              <li><strong>Big O complexity</strong>
              <br/><img width="60%" src="images/popt/Big-O-Time-Complexity-Chart.png"/></li>
              <li><strong>Appropriate data structures</strong></li>
              <li>Look for already optimized libraries</li>
              <li>Scalarization &amp; parallelization opportunities</li>
            </ul>
          </section>

          <section>
            <h2>Use appropriate algorithm</h2>
            <p>You need to sort 100 Mb of numerical data...</p>
            <h3>What sorting algorithm would you choose?</h3>
          </section>
        </section>

        <section>
          <section>
            <h2>Optimize memory access patterns</h2>
            <ul>
              <li>You'll be surprised how many algorithms are memory bound</li>
              <li>It is crucial to load only data that is really needed for computations</li>
            </ul>
            <p>Usually involves:</p>
            <dl>
              <dt><strong>Data restructuring</strong></dt>
              <dd>to use only needed bytes</dd>
              <dt><strong>Data packaging</strong></dt>
              <dd>to shrink data in size</dd>
              <dt><strong>Loop transformations</strong></dt>
              <dd>
                <ul>
                  <li>to walk through data in more efficient way,</li>
                  <li>to increase temporal &amp; spacial locality,</li>
                  <li>to perform cache-aware optimizations</li>
                </ul>
              </dd>
            </dl>
          </section>
          <section>
            <h2>Optimize memory access patterns</h2>
            <div class="cols2">
            <pre><code class="cpp">
    for (int j = 0; j &lt; img.height; j++)
    {
        for (int i = 0; i &lt; img.width; i++)
        {
            if (img.at&lt;uint8_t&gt;(j, i) &gt; 0)
            {
                count++;
            }
        }
    }
            </code></pre>
            <pre><code class="cpp">
    for (int i = 0; i &lt; img.width; i++)
    {
        for (int j = 0; j &lt; img.height; j++)
        {
            if (img.at&lt;uint8_t&gt;(j, i) &gt; 0)
            {
                count++;
            }
        }
    }
            </code></pre>
            </div>
            <br/>
            <h3>Which is more optimal for conventional CPU processor?</h3>
          </section>
        </section>

        <section>
          <section>
            <h2>Minimize number of operations</h2>
            <blockquote>Reducing in the number of program operations does not necessarily decrease its running time, but it is
  a good heuristic though.</blockquote>
            <p>A Compiler is good in local optimizations. So they usually helps a lot here:</p>
            <div class="cols2">
              <ul>
                <li>Machine-independent optimizations
                  <ul>
                    <li>Eliminating common sub-expressions</li>
                    <li>Constant propagation</li>
                    <li>Redundancy elimination</li>
                    <li>..</li>
                  </ul>
                </li>
                <br/>
                <li>Machine-dependent optimizations
                  <ul>
                    <li>Register allocation</li>
                    <li>InstrucIon selecIon</li>
                    <li>Instruction scheduling</li>
                    <li>Peephole opImizaIon</li>
                    <li>..</li>
                  </ul>
                </li>
              </ul>
            </div>
            <p>But sometimes it fails one of this steps and harms the performance.</p>
            <p>Starting from this optimization step it is worth to look at the assembly code to check whether
            the compiler is actually automating a particular optimization.</p>
          </section>
          <section>
            <h2>Minimize number of operations</h2>
            <pre><code class="cpp">
    // original code
    unsigned foo(unsigned char i)
    { // 3x shifts, 3x or
        return i | (i<<8) | (i<<16) | (i<<24);
    }
            </code></pre>
            <pre><code class="cpp">
    // what compiler did
    unsigned foo(unsigned char i)
    { // 1x multiply
        return i*0x01010101;
    }
            </code></pre>
            <h3>Are they same?</h3>
          </section>
        </section>

        <section>
          <h2>Shrink the critical path</h2>
          <dl>
            <dt><strong>Critical path</strong></dt>
            <dd>is <b>the longest</b> sequence of operations in a code block which must be completed <b>in order</b>.
            It is caused by dependencies between operations.</dd>
          </dl>
            <pre><code class="cpp">
    for (int col = 0; col < cols; ++col)
    {
        dptr[col] = (sptr0[col*2] + sptr0[col*2+1] + sptr1[col*2] + sptr1[col*2+1] + 2) >> 2;
    }
            </code></pre>
            <h3>What is the critical path of this code line?</h3>
            <p></p>
        </section>

        <section>
          <h2>Perform HW specific optimizations</h2>
          <p>Require comprehensive understanding of target HW,<br/> that are usually beyond of compiler abilities</p>
          <ul>
            <li>Using instructions, which are specific for concrete hardware</li>
            <li>Using special hardware capabilities</li>
            <li>Overcoming micro-architecture weakness</li>
          </ul>
        </section>

        <section>
          <h2>Dive into assembly</h2>
          <p>Assembler is very often used to check the compiler<br/>and rarely used to write low-level code.</p>
          <p>Raw assembly make sense to:</p>
          <ul>
            <li>Overcome compiler bugs & optimization limitation
              <ul>
                <li>additional instructions</li>
                <li>suboptimal register allocation</li>
              </ul>
            </li>
            <li>Use specific hardware features
              <ul>
                <li>which are not expressed in higher level ISA</li>
              </ul>
            </li>
          </ul>
        </section>

        <section id="end1">
          <h1>THE END</h1>
          <img class="simple" width="30%" src="images/popt/infinity.png">
          <h4><a href="https://github.com/cuda-geek">Marina Kolpakova</a> / 2015</h4s>
        </section>

      </div>

    </div>

    <script src="plugin/reveal/lib/js/head.min.js"></script>
    <script src="plugin/reveal/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: true,
        history: true,
        // center: false,

        width: 960,
        height: 720,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'plugin/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
