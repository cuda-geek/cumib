<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Pragmatic optimization in modern programming</title>
    <meta name="description" content="Pragmatic optimization in modern programming - Introduction">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="plugin/reveal/css/reveal.css">
    <link rel="stylesheet" href="plugin/reveal/css/theme/geek.css" id="theme">
    <link rel="stylesheet" href="css/colors-orange.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="plugin/reveal/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'plugin/reveal/css/print/pdf.css' : 'plugin/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="plugin/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <h1>Pragmatic optimization</h1>
          <h2>in modern programming</h2>
          <h3>Ordering optimization approaches</h3>
          <br>
          <br>
          <br>
          <small>Created by
            <a href="http://github.com/cuda-geek">Marina Kolpakova</a>
            for
            <a href="http://www.unn.ru/eng/">UNN</a>
          </small>
        </section>

        <section>
          <h2>Outline</h2>
          <ul>
            <!-- <li>This course and its goals</li> -->
            <li>What is optimization?</li>
            <li>Pragmatic approach</li>
            <li>Place of optimization in a project life cycle</li>
            <li>Ordering optimization techniques</li>
            <li>Overview of optimization steps</li>
          </ul>
        </section>

<!--         <section>
          <h2>Course goals</h2>
          <ul>
            <li>Master common optimization approaches</li>
            <li>Understand architecture details and trends</li>
            <li>Emphasize critical HW features to look on</li>
            <li>Highlight possible pitfalls</li>
          </ul>
        </section> -->

<!--         <section>
          <h2>Themes &amp; Contents</h2>
          <ul>
            <li><strong>Pragmatics</strong>
              <ul>
                <li>Ordering optimization approaches</li>
                <li>Demystifying a compiler</li>
                <li>Mastering optimization tools</li>
              </ul>
            </li>
            <li><strong>Computer Architectures</strong>
              <ul>
                <li>Architecture of modern computers</li>
                <li>Memory hierarchy</li>
                <li>Pipelining</li>
                <li>Latency vs Throughput architectures</li>
              </ul>
            </li>
            <li><strong>Optimization technologies</strong>
              <ul>
                <li>Multi-core programming</li>
                <li>SIMD extensions</li>
                <li>Specific coprocessors</li>
              </ul>
            </li>
          </ul>
        </section> -->
<!-- style="margin-left: 5em;" -->
        <section>
          <h2>How to learn optimization?</h2>
          <p><strong>Optimization is a <b>craft</b> more than a <b>science</b></strong>. Thereupon,</p>
          <dl>
            <dt><b>Practice more</b></dt>
            <dd>do not make practical knowledge too theoretical.</dd>
            <br/>
            <dt><b>Look, what other people do</b></dt>
            <dd>do find real use-cases of different optimization approaches and techniques.</dd>
            <br/>
            <dt><b>Dig into an architecture</b></dt>
            <dd>hardware evolves very fast hence today's devices are becoming obsolete very quickly. Comprehensive
            knowledge helps to see beforehand.</dd>
          </dd>
        </section>

        <section>
          <section>
            <h2>Recommended literature</h2>
            <img width="30%" src="images/popt/hp.jpg">
            <p>
              <a href="http://www.amazon.com/Computer-Architecture-Fifth-Quantitative-Approach/dp/012383872X/ref=asap_bc?ie=UTF8">
                Computer Architecture, Fifth Edition: A Quantitative Approach</a><br/>by
              <a href="http://www.computerhistory.org/fellowawards/hall/bios/John,Hennessy/">John L. Hennessy</a>
              and
              <a href="https://www.eecs.berkeley.edu/Faculty/Homepages/patterson.html">David A. Patterson.</a>
            </p>
          </section>

          <section>
            <h2>Recommended literature</h2>
            <img src="images/popt/moh.jpg">
            <p>
              <a href="http://carlos.bueno.org/optimization/mature-optimization.pdf">The Mature Optimization Handbook</a>
              by <a href="http://carlos.bueno.org/about.html">Carlos Bueno</a>
            </p>
          </section>

          <section>
            <h2>Recommended literature</h2>
            <img width="30%" src="images/popt/pm.jpg">
            <p><a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook-1c.2015.01.31a.pdf">
              Is Parallel Programming Hard, And, If So, What Can You Do About It?</a><br/> by
              <a href="http://www.rdrop.com/~paulmck/">Paul E. McKenney</a>
            </p>
          </section>
        </section>

        <section>
          <h2>What is optimization?</h2>
          <blockquote>In computing, <b>optimization</b> is the process of modifying a system to make some aspect of it
            work more efficiently or use fewer resources.
            <br/> In particular, this is a process of transforming a piece of code to make it
            <b>more efficient without changing its output</b>.
          </blockquote>
          <p>Metrics which are commonly considered:</p>
          <dl>
            <dt ><b>Wall(-clock) time</b></dt>
            <dd style="margin-left: 5em;">
              <strong>is a human perception of the passage of time from the start to the completion of a task.</strong>
            </dd>
            <br/>
            <dt><b>Power consumption</b></dt>
            <dd style="margin-left: 5em;">is the electrical energy over time which is supplied to complete a task.</dd>
            <br/>
            <dt><b>processor time</b></dt>
            <dd style="margin-left: 5em;">is the total execution time (or runtime) for which a processor was dedicated
            to a task (i.e. used for processing instructions of that task).</dd>
          </dl>
        </section>

        <section>
          <h2>Pragmatic approach</h2>
          <blockquote>
          &ldquo;Programmers waste enormous amounts of time thinking about, or worrying about, the speed of non-critical
          parts of their programs, and these attempts at efficiency actually have a strong negative impact when
          debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time;
          <b>premature optimization is the root of all evil</b>. Yet we should not pass up our opportunities in
          that critical 3%.&ldquo;
            <div style="text-align:right;">
              <br/>
              <small>-Donald Knuth, Structured Programming With go to Statements</small>
            </div>
          </blockquote>
          <br/>
          <ol>
            <li>You ought to find what to start with (3%)</li>
            <li>You ought to know where to stop (97%)</li>
          </ol>
        </section>

        <section>
          <h2>Knowledge which is required</h2>
          <ol>
            <li><b>The code</b>
              <ul>
                <li>The problem, it solves</li>
                <li>The algorithm, it implements</li>
                <li>The algorithmic complexity</li>
              </ul>
            </li>
            <br/>
            <li><b>The compiler</b>
              <ul>
                <li>Compilation trajectory</li>
                <li>Compiler's capabilities and obstacles</li>
              </ul>
            </li>
            <br/>
            <li><b>The platform</b>
              <ul>
                <li>Architecture capabilities
                  <ul>I<small style="vertical-align: bottom">nstruction</small>
                      S<small style="vertical-align: bottom">set</small>
                      A<small style="vertical-align: bottom">rchitecture</small></ul>
                </li>
                <li>Micro-architecture specifics</li>
              </ul>
            </li>
          </ol>
        </section>

        <section>
          <section>
            <h2>Project life cycle</h2>
            <img class="simple" src="images/popt/pdl.svg"/>
          </section>

          <section>
            <h2>Project life cycle</h2>
            <img class="simple" src="images/popt/pdl2.svg"/>
          </section>
        </section>

        <section>
          <h2>Optimization cycle</h2>
          <img class="simple" src="images/popt/opt_cycle.svg"/>
        </section>

        <section>
          <section>
            <h2>From whence get performance?</h2>
            <dl>
              <dt><b>Algorithm</b></dt>
              <dd>Compilers are not aware about semantics of your code,<br>at this rate focus on algorithmic
              aspect first.<br>
                <ul>
                  <li>Decrease big-O complexity</li>
                  <li>Use optimized libraries for sub-routines</li>
                  <li>Restructure the code</li>
                  <li>Split problem on sub-tasks</li>
                  <li>Parallelize</li>
                </ul>
              </dd>
          </section>
          <section>
            <h2>From whence get performance?</h2>
            <dl>
              <dt><b>Memory access patterns &amp; operations</b></dt>
              <dd>
                Compilers are quite good in local optimization such as
                <br/>
                <ul>
                  <li>transforming loop bodies,</li>
                  <li>in-lining local functions,</li>
                  <li>simplifying arithmetic expressions</li>
                </ul>
                <br/>so help a compiler rather than try to outfox it.<br/><br/>
                Work cohesively with it on<br/>
                <ul>
                  <li>enabling auto-vectorization,</li>
                  <li>optimizing critical loops,</li>
                  <li>vectorizing.</li>
                </ul>
              </dd>
            </dl>
          </section>
          <section>
            <h2>From whence get performance?</h2>
            <dl>
              <dt><b>HW specific optimizations</b></dt>
              <dd>
                <ul>
                  <li>Utilize unique properties of the hardware</li>
                </ul>
                <br>Modern hardware is quite advanced,<br>
                <ul>
                  <li>deep pipelines,</li>
                  <li>out-of-order execution,</li>
                  <li>sophisticated branch prediction,</li>
                  <li>multi-level memory hierarchies,</li>
                  <li>processor specialization.</li>
                </ul><br>
                so peephole optimizations are not as important as it used to be 10 years ago.<br>
              </dd>
            </dl>
          </section>
          <section>
            <h2>From whence get performance?</h2>
            <br/><br/>
            <table style="font-size:1.5em;">
              <colgroup>
                <col></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td style="margin-top:0.5em;">High-level</td>
                  <td style="margin-top:0.5em;">Programmer</td>
                </tr>
                <tr>
                  <td style="margin-top:0.5em;">Middle-level</td>
                  <td style="margin-top:0.5em;">Compiler</td>
                </tr>
                <tr>
                  <td style="margin-top:0.5em;">Low-level</td>
                  <td style="margin-top:0.5em;">Hardware</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>

        <section>
          <h2>Top-Down (High-low) approach</h2>
          <ol style="font-size:1.5em;">
            <li>Use appropriate algorithms</li>
            <br/>
            <li>Optimize memory access patterns</li>
            <li>Minimize number of operations</li>
            <br/>
            <li>Shrink a critical path</li>
            <li>Perform HW specific optimizations</li>
            <br/>
            <li>Dive into assembly</li>
          </ol>
        </section>

        <section>
          <h2>Optimization tread-offs</h2>
          <ul>
            <li>Code portability decreases when we go deeper</li>
            <li>Performance portability decreases when we go deeper</li>
            <li>The cost of maintenance &amp; extendability increases when we go deeper</li>
            <li>Optimizations are often not reusable</li>
            <li>Optimizations become obsolete very quickly</li>
          </ul>
          <br/><br/>
          <strong>...but still performance is a crucial requirement for most applications.</strong>
        </section>

        <section>
          <h2>step #1: Understand the code</h2>
          <ul>
            <li>Different people think differently
              <ul>
                <li>you'll need a time to get used to the code</li>
              </ul>
            </li>
            <li>Understand dataflow
              <ul>
                <li>input parameters</li>
                <li>output results</li>
                <li>data dependencies</li>
              </ul>
            </li>
            <li><b>Identify performance limiters</b>
              <ul>
                <li>Time</li>
                <li>Profile</li>
                <li>Grub metrics
                  <ul>
                    <li>eg power consumption</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Step #2: use appropriate algorithm</h2>
            <p>Consider:</p>
            <ul>
              <li><strong>Big O complexity</strong>
              <br/><img width="80%" src="images/popt/Big-O-Time-Complexity-Chart.png"/></li>
              <li><strong>Use of data structures</strong></li>
              <li>Use of already optimized libraries</li>
              <li>Opportunities for scalarization &amp; parallelization</li>
            </ul>
          </section>

          <section>
            <h2>Step #2: use appropriate algorithm</h2>
            <p>You need to sort 100 Mb of numerical data...</p>
            <h3>What sorting algorithm would you choose?</h3>
          </section>
        </section>

        <section>
          <section>
            <h2>Step #3: optimize memory access patterns</h2>
            <ul>
              <li>You'll be surprised how many algorithms are memory bound</li>
              <li>It is crucial to load only data that is really needed for computations</li>
            </ul>
            <p>Optimization for a memory usually involves:</p>
            <dl>
              <dt><b>Data restructuring</b></dt>
              <dd>
                <ul>
                  <li>to use only needed bytes</li>
                  <li>to walk through data in more efficient way,</li>
                </ul>
              </dd><br/>
              <dt><b>Data packaging</b></dt>
              <dd>to shrink data in size</dd><br/>
              <dt><b>Loop transformations</b></dt>
              <dd>
                <ul>
                  <li>to walk through data in more efficient way,</li>
                  <li>to increase temporal &amp; spacial locality,</li>
                  <li>to perform cache-aware optimizations</li>
                </ul>
              </dd>
            </dl>
          </section>

          <section>
            <h2>Step #3: optimize memory access patterns</h2>
            <table class="simple">
              <colgroup>
                <col></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code class="cpp">
for (int j = 0; j &lt; img.height; j++)
{
    for (int i = 0; i &lt; img.width; i++)
    {
        if (img[j * img.width + i] &gt; 0)
        {
            count++;
        }
    }
}
                    </code></pre>
                  </td>
                  <td>
                    <pre><code class="cpp">
for (int i = 0; i &lt; img.width; i++)
{
    for (int j = 0; j &lt; img.height; j++)
    {
        if (img[j * img.width + i] &gt; 0)
        {
            count++;
        }
    }
}
                    </code></pre>
                  </td>
              </tbody>
            </table>
            <br/>
            <h3>Which is more optimal for conventional CPU processor?</h3>
          </section>
          <section>
            <h2>Step #3: optimize memory access patterns</h2>
            <table class="simple">
              <colgroup>
                <col></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre style="border: 3px double #FF8D14;"><code class="cpp">
for (int j = 0; j &lt; img.height; j++)
{
    for (int i = 0; i &lt; img.width; i++)
    {
        if (img[j * img.width + i] &gt; 0)
        {
            count++;
        }
    }
}
                    </code></pre>
                  </td>
                  <td>
                    <pre><code class="cpp">
for (int i = 0; i &lt; img.width; i++)
{
    for (int j = 0; j &lt; img.height; j++)
    {
        if (img[j * img.width + i] &gt; 0)
        {
            count++;
        }
    }
}
                    </code></pre>
                  </td>
              </tbody>
            </table>
            <br/>
          </section>
        </section>

        <section>
          <section>
            <h2>Step #4: minimize number of operations</h2>
            <blockquote>Reducing a program in the number of operations
            <br/> does not necessarily decrease its running time,
            <br/>but it is a good heuristic, though.</blockquote>
            <br/>
            <p>A Compiler is good in local optimizations, so it usually helps a lot here:</p>
            <table class="simple">
              <colgroup>
                <col></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td  style="padding-left:1.5em;" width="50%">
                    <b>Machine-independent optimizations</b>
                    <ul>
                      <li>Eliminating common sub-expressions</li>
                      <li>Constant propagation</li>
                      <li>Redundancy elimination</li>
                      <li>..</li>
                    </ul>
                  </td>
                  <td>
                    <b>Machine-dependent optimizations</b>
                    <ul>
                      <li>Register allocation</li>
                      <li>InstrucIon selecIon</li>
                      <li>Instruction scheduling</li>
                      <li>Peephole opImizaIon</li>
                      <li>..</li>
                    </ul>
                  </td>
              </tbody>
            </table>
          </section>
          <section>
            <h2>Step #4: minimize number of operations</h2>
            <img src="images/popt/g2rgba.svg" class="simple" width="60%" />
            <pre><code class="cpp">
uint32_t gray2rgba_v1(uint8_t c)
{
  return c + (c<<8) + (c<<16) + (c<<24);
}
            </code></pre>
            <pre><code class="cpp">
uint32_t gray2rgba_v2(uint8_t c)
{
  return c * 0x01010101;
}
            </code></pre>
            <h3>Are they same?</h3>
          </section>
          <section>
            <h2>Step #4: minimize number of operations</h2>
            <pre><code class="asm">
gray2rgba_v1:
.LFB0:
  .cfi_startproc
  movzbl  %dil, %eax
  imull $16843009, %eax, %eax
  ret
  .cfi_endproc

            </code></pre>
            <pre><code class="asm">
gray2rgba_v2:
.LFB2:
  .cfi_startproc
  movzbl  %dil, %eax
  imull $16843009, %eax, %eax
  ret
  .cfi_endproc

            </code></pre>
            <h3>Are they same?</h3>
            <code>gcc -O2  -S 1.c -o 1.s ; cat 1.s</code>
          </section>
          <section>
            <h2>Step #4: minimize number of operations</h2>
            <p>Unfortunately, sometimes a compiler fails some optimization steps<br/>and harms the performance by
            introducing redundant operations.</p>
            <p>More often failed steps are:</p>
            <ul>
              <li>Register allocation</li>
              <li>Scalarization</li>
            </ul>
            <p><blockquote><strong>Starting from this optimization step it is worth to <b>look at the assembly code</b> to check
             whether the compiler is actually automating a particular optimization.</strong></blockquote></p>
          </section>
        </section>

        <section>
          <h2>Step #5: shrink the critical path</h2>
          <dl>
            <dt><strong>Critical path</strong></dt>
            <dd>is <b>the longest</b> sequence of operations in a code block which must be completed <b>in order</b>.
            It is caused by dependencies between operations.</dd>
          </dl>
            <pre><code class="cpp">
    for (int col = 0; col < cols; ++col)
    {
        dptr[col] = (sptr0[col*2] + sptr0[col*2+1] + sptr1[col*2] + sptr1[col*2+1] + 2) >> 2;
    }
            </code></pre>
            <h3>What is the critical path of this code line?</h3>
            <p></p>

        </section>

        <section>
          <h2>Step #6: perform HW specific optimizations</h2>
          <p>Require comprehensive understanding of target HW,<br/> that are usually beyond of compiler abilities</p>
          <ul>
            <li>Using instructions, which are specific for concrete hardware</li>
            <li>Using special hardware capabilities</li>
            <li>Overcoming micro-architecture weakness</li>
          </ul>
        </section>

        <section>
          <h2>Step #7: dive into assembly</h2>
          <blockquote>Assembler is very often used to check the compiler<br/>and rarely used to write low-level code.</blockquote>
          <p>Raw assembly make sense to:</p>
          <ul>
            <li>Overcome compiler bugs & optimization limitations
              <ul>
                <li>addition of redundant instructions</li>
                <li>suboptimal register allocation</li>
              </ul>
            </li>
            <br/>
            <li>Use specific hardware features
              <ul>
                <li>which are not expressed in higher level ISA</li>
              </ul>
            </li>
          </ul>
          <p>Keep in mind that:</p>
          <ul>
            <li>Hand-written assembly is the least portable optimization</li>
            <li>In-line assembly insertions limit compiler abilities for further optimizations</li>
          </ul>
        </section>

        <section id="end1">
          <h1>THE END</h1>
          <img class="simple" src="images/popt/infinity.png">
          <h4><a href="https://github.com/cuda-geek">Marina Kolpakova</a> / 2015</h4s>
        </section>

      </div>

    </div>

    <script src="plugin/reveal/lib/js/head.min.js"></script>
    <script src="plugin/reveal/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: true,
        history: true,
        center: false,

        width: 960,
        height: 720,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'plugin/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
