<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Pragmatic optimization in modern programming</title>
    <meta name="description" content="Pragmatic optimization in modern programming - Introduction">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="plugin/reveal/css/reveal.css">
    <link rel="stylesheet" href="plugin/reveal/css/theme/geek.css" id="theme">
    <link rel="stylesheet" href="css/colors-orange.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="plugin/reveal/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'plugin/reveal/css/print/pdf.css' : 'plugin/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="plugin/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <h1>Pragmatic optimization</h1>
          <h2>in modern programming</h2>
          <h3>Mastering compiler optimizations</h3>
          <br>
          <br>
          <br>
          <small>Created by
            <a href="http://github.com/cuda-geek">Marina Kolpakova</a>
            for
            <a href="http://www.unn.ru/eng/">UNN</a>
          </small>
        </section>

        <section>
          <h2>Themes &amp; Contents</h2>
          <ul>
            <li><strong>Pragmatics</strong>
              <ul>
                <li>Ordering optimization approaches</li>
                <li>Demystifying a compiler</li>
                <li><b>Mastering compilation</b></li>
              </ul>
            </li>
            <li><strong>Computer Architectures</strong>
              <ul>
                <li>Architecture of modern computers</li>
                <li>SIMD extensions</li>
                <li>Specific co-processors</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2>Do not optimize debug versions.</h2>
          <p>Learn a compiler well and stick with it.</p>
        </section>

<!--         <section>
          <h2>Outline</h2>
          <ul>
            <li>Taxonomy of compiler optimizations</li>
            <li>Case studies
              <ol>
                <li>Function body inlining</li>
                <li>Loop counter elimination</li>
                <li>Loop peeling</li>
                <li>Loop unrolling</li>
                <li>Scalarization</li>
                <li>Auto-vectorization</li>
              </ol>
            </li>
            <li>Self-study</li>
          </ul>
        </section> -->

        <section>
          <section>
            <h2>Classic taxonomy</h2>
            <ul>
              <li>
                <b>Machine independent transformations</b>
                <ol>
                  <li><strong>Applicable across a broad range of machines</strong></li>
                  <li>Eliminate redundant computations</li>
                  <li>Decrease ratio of overhead to real work</li>
                  <li>Reduce running time or space</li>
                  <li>Specialize code on a context</li>
                  <li>Eliminate dead code</li>
                  <li>Enable other optimizations</li>
                </ol>
              </li>
              <li>
                <b>Machine dependent transformations</b>
                <ol>
                  <li><strong>Capitalize on specific machine properties</strong></li>
                  <li>Manage or hide latency</li>
                  <li>Improve the mapping from IR to this machine</li>
                  <li>Might use some exotic instructions (eg VLDM )</li>
                </ol>
              </li>
            </ul>
          </section>

          <section>
            <h2>Compiler optimizations taxonomy</h2>
            <img src="images/popt/opt_machine_independent.png" alt="machine independent optimizations" style="padding:15px; background:white">
          </section>

          <section>
            <h2>Compiler optimizations taxonomy</h2>
            <img src="images/popt/opt_machine_dependent.png" alt="machine dependent optimizations" style="padding:15px; background:white">
          </section>
        </section>

        <section>
          <section>
            <h2>Copy propagation</h2>
            <p>Eliminates all copies of the variable. Simplifies intermediate representation.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
int x = y
int z = 1 + x

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
int x = y
int z = 1 + y

</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Constant folding</h2>
            <p>Evaluates expressions from the constants in compile time. Expressions could be quite complicated,
            but absence of side effect is always a concern.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
int add = 100;
int aug = 200;
int sum = add + aug;

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
int sum = 300;

</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Strength Reduction</h2>
            <p>Replaces complex expressions with more simple analogy.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
double x = pow(y, 2.0);
double a = c / 2.0;

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
double x = y * y;
double a = c * 0.5;

</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Common Subexpression Elimination</h2>
            <p>Cache expression result into variable for future use. Sometimes you need to depict them in code, to help
            the compiler detect them.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
double d = c * (a / b);
double e = (a / b) * 2.0;

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
double adivb = a / b;

double d = c * adivb;
double e = adivb * 2.0;

</code></pre>
              </li>
            </ul>
          </section>
        </section>

        <section>
          <h2>Scope taxonomy</h2>
          <ul>
            <li>High­-level optimizations
              <ul>
                <li>Loop optimizations</li>
              </ul>
            </li>
            <li>Inter-procedural optimization</li>
            <li>Intra-procedural optimization</li>
            <li>Global optimizations</li>
            <li>Local optimizations</li>
            <li>Peephole optimizations</li>
          </ul>
        </section>

        <section>
          <h2>Code Pattern taxonomy</h2>
          <ul>
            <li>Function class and sub-routines</li>
            <li>Dependency chains (linear code)</li>
            <li>Branches</li>
            <li><strong>Loop bodies</strong></li>
          </ul>
        </section>

        <section>
          <h2>Function body inlining</h2>
          <p>Replace functional call to function body. <strong>Enables all further optimizations.</strong></p>
          <ul class="none">
            <li>Before
              <pre><code class="cpp">
int square(int x)
{
  return x*x;
}

for (int i = 0; i < N; i++)
  a[i] = square(i);
</code></pre>
            </li>
            <li>After
              <pre><code>
for (int i = 0; i < N; i++)
  a[i] = i*i;
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>List of loop optimization</h2>
          <ul>
            <li><strong>Single loop (usually the inner)</strong>
              <ul>
                <li>Loop-induction variable elimination</li>
                <li>Hoisting Loop Invariant Code</li>
                <li>Loop unrolling</li>
                <li>Loop unswitching</li>
                <li>Scalarization</li>
                <li>Strip mining</li>

                <!-- <li>Loop skewing</li> -->
                <!-- <li>Unroll-and-jam</li> -->
                <!-- <li>Loop reversal</li> -->


<!--
    Loop peeling
    Loop reversal
 -->

              </ul>
            </li>
            <li><strong>Multi-loop</strong>
              <ul>
                <li>Loop fusion/fission</li>
                <li>Loop interchange</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2>#1: Loop-induction variable elimination</h2>
          <p>In most cases compiler able to replace address arithmetics with pointer arithmetics. <strong>Most
          hand-written pointer optimizations do not make sense with usage optimization levels hither than O0.</strong></p>
          <ul class="none">
            <li>Before
              <pre><code class="cpp">
void function(int* arr, int len)
{
  for (int i = 0; i < len; i++)
    arr[i] = 1;
}

</code></pre>
            </li>
            <li>After
          <pre><code class="cpp">
void function(int* arr, int len)
{
  for (int* p = arr; p < arr + 10000; p++)
      *p = 1;
}

</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#2: Hoisting Loop Invariant Code</h2>
          <p>The goal of <b>hoisting</b> — also called <b>loop-invariant code motion</b> — is to avoid recomputing
          loop-invariant code each time through the body of a loop.</p>
          <ul class="none">
            <li>Before
              <pre><code class="cpp">#include &lt;math.h&gt;

void scale(double* X, double* Y, int len)
{
  for (int i = 0; i < len; i++)
    Y[i] = X[i] * exp(sqrt(M_PI/2));
}

</code></pre>
            </li>
            <li>After
              <pre><code class="cpp">#include &lt;math.h&gt;

void scale(double* X, double *Y, int len)
{
  double factor = exp(sqrt(M_PI/2));

  for (int i = 0; i < len; i++)
    Y[i] = X[i] * factor;
}
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#3: Loop unrolling</h2>
          <p>Generates multiple copies of the code for the loop body, reduces number of branches and groups more
          instructions together to enable more efficient instruction pipelining. Best candidates are innermost loops
          with limited control flow.</p>
          <ul class="none:">
            <li>Before
              <pre><code class="cpp">
for (int i = 0 ; i < N; i++)
  h[p[i]]++;

</code></pre>
            </li>
            <li>After
              <pre><code class="cpp">
for (int i = 0 ; i <= N-4; i+=4)
{
  int idx0 = p[i+0]; int idx1 = p[i+1];
  int idx2 = p[i+2]; int idx3 = p[i+3];

  h[idx0]++; h[idx1]++;
  h[idx2]++; h[idx3]++;
}

</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>#4: Loop unswitching &amp; Scalarization</h2>
            <p>Moves loop-invariant conditional constructs or switches which are independent of the loop index out of
            the loop. Increases instruction level parallelism, enables further optimizations.</p>
            <ul class="none:">
              <li>Before
                <pre><code class="cpp">for (int i = 0; i < N; i++)
{
    if (a > 0)
        X[i] = a;
    else
        X[i] = 0;
}
</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">if (a > 0)
{
    for (int i = 0; i < N; i++)
        X[i] = a;
}
else
{
    for (int i = 0; i < N; i++)
        X[i] = 0;
}
</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Scalarization</h2>
            <p>Both compiled to the same instruction sequence</p>
            <ul class="none:">
              <li>Before
                <pre><code class="cpp">int regular(int i)
{
  if (i&gt;5 && i&lt;00)
    return 1;
  return 0;
}
</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">int clever(int i)
{
  return (((unsigned)i) - 6 > 93);
}
</code></pre>
              </li>
              <li>Assembly
            <pre><code class="asm">subl  $6, %edi
cmpl  $93, %edi</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Advanced unswitching: Sentinels</h2>
            <p>Sentinels are special dummy values placed in a data structure to simplify the logic of boundary conditions,
  and in particular, the handling of loop-exit tests.</p>

            <ul class="none">
              <li>Before
                <pre style="display:inline;"><code class="cpp">bool overflow(uint64_t* A, size_t n)
{
  uint64_t sum = 0;
  for (size_t i = 0; i < n; ++i)
  {
    sum += A[i];
    if (sum < A[i])
      return true;
  }
  return  false;
}</code></pre>
              </li>
              <li>After
                  <pre style="display:inline;"><code class="cpp">bool overflow(uint64_t* A, size_t n)
{
  A[n] = UINT64_MAX, A[n+1] = 0;
  size_t i = 0; uint64_t sum = A[0];
  while ( sum >= A[i])
    sum += A[++i];

  return (i < n);
}</code></pre>
              </li>
            </ul>
          </section>
        </section>
<!--  -->
        <section>
          <h2>#5: Strip mining</h2>
          <p></p>
          <ul class="none:">
            <li>Before
              <pre><code>
do I = 1, n
  do J = 1, n
    A(J,I) = B(J) ∗ C(I)
</code></pre>
            </li>
            <li>After
              <pre><code>
do II = 1, n, tile
  do J = 1, n
    do I = II, II + tile -1
      A(J,I) = B(J) ∗ C(I)
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#8: Loop Interchange</h2>
          <ul class="none">
            <li>Before
              <pre><code>
DO j = 1, nj
  DO i = 1, ni
    a(i,j) = b(i,j)
  END DO
END DO
</code></pre>
            </li>
            <li>After
              <pre><code>
DO i = 1, ni
  DO j = 1, nj
    a(i,j) = b(i,j)
  END DO
END DO
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#9: Loop Fusion / Fission</h2>
          <p>Fusion: fewer branches (combine with unrolling). fewer total memory references. <br/>
          Fission: smaller cache footprint.</p>
          <ul class="none">
            <li>Before
              <pre><code>
DO i = 1, n
  b(i) = a(i) + 1
END DO

DO i = 1, n
  c(i) = b(i) / 2
END DO

DO i = 1, n
  d(i) = 1.f / c(i)
END DO
</code></pre>
            </li>
            <li>After
              <pre><code>
DO i = 1, n
  b(i) = a(i) + 1
  c(i) = b(i) / 2
  d(i) = 1.f / c(i)
END DO
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Auto-vectorization</h2>
            <ul>
              <li>Machine code generation that takes advantage of vector instructions.</li>
              <li>Most of all modern architectures have vector units (co-processors or specialized pipes)
                <ul>
                  <li>MMX, SSE, SSE2, SSE4, AVX, AVX-512</li>
                  <li>AltiVec, VSX</li>
                  <li>ASIMD (NEON), MSA</li>
                </ul>
              </li>
              <li>Enabled by inlining, unrolling, fusion, software pipelining, inter-procedural optimization, etc.</li>
            </ul>
          </section>
          <section>
            <p>absdiff -03 or hand-written assembly</p>
          </section> -->
        </section>

        <!-- <section> -->
          <!-- <h2>IPA: Interprocedural optimization</h2> -->
          <!-- https://gcc.gnu.org/onlinedocs/gccint/IPA.html -->
          <!-- https://en.wikipedia.org/wiki/Interprocedural_optimization -->
        <!-- </section> -->

<!--         <section>
          <h2>Register allocation</h2>
          <p>CSO (common subexpression optimization) and register allocation</p>
          <p>16-32 registers are optimal register number for the compiler</p>
        </section> -->

        <section id="end1">
          <h1>THE END</h1>
          <img class="simple" src="images/popt/infinity.png">
          <h4><a href="https://github.com/cuda-geek">Marina Kolpakova</a> / 2015</h4s>
        </section>

      </div>

    </div>

    <script src="plugin/reveal/lib/js/head.min.js"></script>
    <script src="plugin/reveal/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: true,
        history: true,
        center: false,

        width: 960,
        height: 720,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'plugin/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
