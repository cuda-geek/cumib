<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Pragmatic optimization in modern programming</title>
    <meta name="description" content="Pragmatic optimization in modern programming - Introduction">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="plugin/reveal/css/reveal.css">
    <link rel="stylesheet" href="plugin/reveal/css/theme/geek.css" id="theme">
    <link rel="stylesheet" href="css/colors-orange.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="plugin/reveal/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'plugin/reveal/css/print/pdf.css' : 'plugin/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="plugin/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <h1>Pragmatic optimization</h1>
          <h2>in modern programming</h2>
          <h3>Mastering compiler optimizations</h3>
          <br>
          <br>
          <br>
          <small>Created by
            <a href="http://github.com/cuda-geek">Marina Kolpakova</a>
            for
            <a href="http://www.unn.ru/eng/">UNN</a>
          </small>
        </section>

        <section>
          <h2>Themes &amp; Contents</h2>
          <ul>
            <li><strong>Pragmatics</strong>
              <ul>
                <li>Ordering optimization approaches</li>
                <li>Demystifying a compiler</li>
                <li><b>Mastering compiler optimizations</b></li>
              </ul>
            </li>
            <li><strong>Computer Architectures</strong>
              <ul>
                <li>Architecture of modern computers</li>
                <li>SIMD extensions</li>
                <li>Specific co-processors</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2>Are you still optimizing debug versions?</h2>
          <br/><br/><br/><br/>
          <h3>Learn a compiler well and stick with it!</h3>
        </section>

<!--         <section>
          <h2>Outline</h2>
          <ul>
            <li>Taxonomy of compiler optimizations</li>
            <li>Case studies
              <ol>
                <li>Function body inlining</li>
                <li>Loop counter elimination</li>
                <li>Loop peeling</li>
                <li>Loop unrolling</li>
                <li>Scalarization</li>
                <li>Auto-vectorization</li>
              </ol>
            </li>
            <li>Self-study</li>
          </ul>
        </section> -->

        <section>
          <section>
            <h2>Classic taxonomy</h2>
            <ul>
              <li>
                <b>Machine independent transformations</b>
                <ol>
                  <li><strong>Applicable across a broad range of machines</strong></li>
                  <li>Eliminate redundant computations</li>
                  <li>Decrease ratio of overhead to real work</li>
                  <li>Reduce running time or space</li>
                  <li>Specialize code on a context</li>
                  <li>Eliminate dead code</li>
                  <li>Enable other optimizations</li>
                </ol>
              </li>
              <li>
                <b>Machine dependent transformations</b>
                <ol>
                  <li><strong>Capitalize on specific machine properties</strong></li>
                  <li>Manage or hide latency</li>
                  <li>Improve the mapping from IR to this machine</li>
                  <li>Might use some exotic instructions (eg VLDM )</li>
                </ol>
              </li>
            </ul>
          </section>

          <section>
            <h2>Compiler optimizations taxonomy</h2>
            <img src="images/popt/opt_machine_independent.png" alt="machine independent optimizations" style="padding:15px; background:white">
          </section>

          <section>
            <h2>Compiler optimizations taxonomy</h2>
            <img src="images/popt/opt_machine_dependent.png" alt="machine dependent optimizations" style="padding:15px; background:white">
          </section>
        </section>

        <section>
          <section>
            <h2>Copy propagation</h2>
            <p>Eliminates all copies of the variable. Simplifies intermediate representation.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
int x = y
int z = 1 + x

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
int x = y
int z = 1 + y

</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Constant folding</h2>
            <p>Evaluates expressions from the constants in compile time. Expressions could be quite complicated,
            but absence of side effect is always a concern.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
int add = 100;
int aug = 200;
int sum = add + aug;

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
int sum = 300;

</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Strength Reduction</h2>
            <p>Replaces complex expressions with more simple analogy.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
double x = pow(y, 2.0);
double a = c / 2.0;

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
double x = y * y;
double a = c * 0.5;

</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Common Subexpression Elimination</h2>
            <p>Cache expression result into variable for future use. Sometimes you need to depict them in code, to help
            the compiler detect them.</p>
            <ul>
              <li>Before
                <pre><code class="cpp">
double d = c * (a / b);
double e = (a / b) * 2.0;

</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">
double adivb = a / b;

double d = c * adivb;
double e = adivb * 2.0;

</code></pre>
              </li>
            </ul>
          </section>
        </section>

        <section>
          <h2>Scope taxonomy</h2>
          <ul>
            <li>HighÂ­-level optimizations
              <ul>
                <li>Loop optimizations</li>
              </ul>
            </li>
            <li>Inter-procedural optimization</li>
            <li>Intra-procedural optimization</li>
            <li>Global optimizations</li>
            <li>Local optimizations</li>
            <li>Peephole optimizations</li>
          </ul>
        </section>

        <section>
          <h2>Code Pattern taxonomy</h2>
          <ul>
            <li>Function class and sub-routines</li>
            <li>Dependency chains (linear code)</li>
            <li>Branches</li>
            <li><strong>Loop bodies</strong></li>
          </ul>
        </section>

        <section>
          <h2>Function body inlining</h2>
          <p>Replace functional call to function body. <strong>Enables all further optimizations.</strong></p>
          <ul class="none">
            <li>Before
              <pre><code class="cpp">
int square(int x)
{
  return x*x;
}

for (int i = 0; i < N; i++)
  a[i] = square(i);
</code></pre>
            </li>
            <li>After
              <pre><code>
for (int i = 0; i < N; i++)
  a[i] = i*i;
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>List of loop optimization</h2>
          <ul>
            <li><strong>Single loop (usually the inner)</strong>
              <ul>
                <li>Loop-induction variable elimination</li>
                <li>Hoisting Loop Invariant Code</li>
                <li>Loop unrolling</li>
                <li>Loop unswitching</li>
                <li>Loop Peeling</li>
                <li>Scalarization</li>
                <li>Strip mining</li>

                <!-- out of scope -->
                <!-- <li>Loop skewing</li> -->
                <!-- <li>Unroll-and-jam</li> -->
                <!-- <li>Loop reversal</li> -->
                <!-- <li>Prefetching</li> -->
                <!-- <li>Test promotion in loops</li> -->
                <!-- <li>Software pipelining</li> -->
                <!-- <li>Array Initialization</li> -->
                <!-- <li>Loop Defactorization</li> -->
                <!-- <li>Outer Loop Unrolling</li> -->
                <!--  -->
              </ul>
            </li>
            <li><strong>Multi-loop (nested or detached)</strong>
              <ul>
                <li>Loop fusion/fission</li>
                <li>Loop interchange</li>
                <li>Stride Minimization</li>
                <li>Loop collapse</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2>#1: Loop-induction variable elimination</h2>
          <p>In most cases compiler able to replace address arithmetics with pointer arithmetics. <strong>Most
          hand-written pointer optimizations do not make sense with usage optimization levels hither than O0.</strong></p>
          <ul class="none">
            <li>Before
              <pre><code class="cpp">
void function(int* arr, int len)
{
  for (int i = 0; i < len; i++)
    arr[i] = 1;
}

</code></pre>
            </li>
            <li>After
          <pre><code class="cpp">
void function(int* arr, int len)
{
  for (int* p = arr; p < arr + 10000; p++)
      *p = 1;
}

</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#2: Hoisting Loop Invariant Code</h2>
          <p>The goal of <b>hoisting</b> â also called <b>loop-invariant code motion</b> â is to avoid recomputing
          loop-invariant code each time through the body of a loop.</p>
          <ul class="none">
            <li>Before
              <pre><code class="cpp">#include &lt;math.h&gt;

void scale(double* X, double* Y, int len)
{
  for (int i = 0; i < len; i++)
    Y[i] = X[i] * exp(sqrt(M_PI/2));
}

</code></pre>
            </li>
            <li>After
              <pre><code class="cpp">#include &lt;math.h&gt;

void scale(double* X, double *Y, int len)
{
  double factor = exp(sqrt(M_PI/2));

  for (int i = 0; i < len; i++)
    Y[i] = X[i] * factor;
}
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#3: Loop unrolling</h2>
          <p>Generates multiple copies of the code for the loop body, reduces number of branches and groups more
          instructions together to enable more efficient instruction pipelining. Best candidates are innermost loops
          with limited control flow.</p>
          <ul class="none:">
            <li>Before
              <pre><code class="cpp">
for (int i = 0 ; i < N; i++)
  h[p[i]]++;

</code></pre>
            </li>
            <li>After
              <pre><code class="cpp">
for (int i = 0 ; i <= N-4; i+=4)
{
  int idx0 = p[i+0]; int idx1 = p[i+1];
  int idx2 = p[i+2]; int idx3 = p[i+3];

  h[idx0]++; h[idx1]++;
  h[idx2]++; h[idx3]++;
}

</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>#4: Loop unswitching</h2>
            <p>Moves loop-invariant conditional constructs or switches which are independent of the loop index out of
            the loop. Increases instruction level parallelism, enables further optimizations.</p>
            <ul class="none:">
              <li>Before
                <pre><code class="cpp">for (int i = 0; i < N; i++)
{
    if (a > 0)
        X[i] = a;
    else
        X[i] = 0;
}
</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">if (a > 0)
{
    for (int i = 0; i < N; i++)
        X[i] = a;
}
else
{
    for (int i = 0; i < N; i++)
        X[i] = 0;
}
</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Loop peeling</h2>
            <p>A small number of iterations from the beginning or end of a loop taken out of the loop and executed
            separately which eliminates if-statements and makes the loop more suitable for vectorization</p>
            <ul class="none:">
              <li>Before
                <pre><code class="cpp">for (int i = 0; i&lt;N; i++)
{
  if (i==0 || i==(N-1))
    b[i] = a[i];
  else
    b[i] = b[i+1] + a[i-1];
}
</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">b[0] = a[0];
for (int i = 0; i&lt;N; i++)
  [i] = b[i+1] + a[i-1];
b[N-1] = a[N-1];
</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Scalarization</h2>
            <p>Both compiled to the same instruction sequence</p>
            <ul class="none:">
              <li>Before
                <pre><code class="cpp">int regular(int i)
{
  if (i&gt;5 && i&lt;00)
    return 1;
  return 0;
}
</code></pre>
              </li>
              <li>After
                <pre><code class="cpp">int clever(int i)
{
  return (((unsigned)i) - 6 > 93);
}
</code></pre>
              </li>
              <li>Assembly
            <pre><code class="asm">subl  $6, %edi
cmpl  $93, %edi</code></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>Advanced unswitching: Sentinels</h2>
            <p>Sentinels are special dummy values placed in a data structure to simplify the logic of boundary conditions,
  and in particular, the handling of loop-exit tests.</p>

            <ul class="none">
              <li>Before
                <pre style="display:inline;"><code class="cpp">bool overflow(uint64_t* A, size_t n)
{
  uint64_t sum = 0;
  for (size_t i = 0; i < n; ++i)
  {
    sum += A[i];
    if (sum < A[i])
      return true;
  }
  return  false;
}</code></pre>
              </li>
              <li>After
                  <pre style="display:inline;"><code class="cpp">bool overflow(uint64_t* A, size_t n)
{
  A[n] = UINT64_MAX, A[n+1] = 0;
  size_t i = 0; uint64_t sum = A[0];
  while ( sum >= A[i])
    sum += A[++i];

  return (i < n);
}</code></pre>
              </li>
            </ul>
          </section>
        </section>
<!--  -->
        <section>
          <h2>#5: Strip mining</h2>
          <p>Also called as blocking or tiling.</p>
          <ul class="none:">
            <li>Before
              <pre><code>
for (int i = 0; i < N; i++)
{
  for (int j = 0; j < N; j++)
  {
    A[i][j] = A[i][j] + B[j][i];
  }
}
</code></pre>
            </li>
            <li>After
              <pre><code>
for (int i = 0; i < N; i += block_size)
{
  for (int j = 0; j < N; j += block_size)
  {
    for (int ii = i; ii < i + block_size; ii++)
    {
      for (int jj = j; jj < j + block_size; jj++)
      {
        A[ii][jj] = A[ii][jj] + B[jj][ii];
      }
    }
  }
}
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#6: Loop Interchange</h2>
            <p>It is usually done for stride Minimization</p>
            <table class="simple">
              <colgroup>
                <col></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code class="cpp">
for (int j = 0; j &lt; height; j++)
{
  for (int i = 0; i &lt; width; i++)
  {
    if (img[j * width + i] &gt; 0)
    {
      count++;
    }
  }
}
                    </code></pre>
                  </td>
                  <td>
                    <pre><code class="cpp">
for (int i = 0; i &lt; width; i++)
{
  for (int j = 0; j &lt; height; j++)
  {
    if (img[j * width + i] &gt; 0)
    {
      count++;
    }
  }
}
                    </code></pre>
                  </td>
              </tbody>
            </table>
        </section>

        <section>
          <h2>#7: Loop Fusion / Fission</h2>
          <ul class="none">
            <li>Loop <b>fission</b> breaks up a complicated loop into multiple smaller loops, iterating over the same
            index range which may help to achieve better locality of reference and reduce register pressure. Fission
            results in smaller cache footprint.
              <pre><code class="cpp">for (size_t i = 0; i < n; ++i)
  b[i] = a[i] + 1.f;

for (size_t i = 0; i < n; ++i)
  c[i] = b[i] / 2.f;

for (size_t i = 0; i < n; ++i)
  d[i] = 1.f / c[i];
</code></pre>
            </li>
            <li>Loop <b>fusion</b> combines multiple loops operating over the same index range into one single loop
            which may lead to better locality of reference, but it may increase register pressure as well. Fusion results
            in fewer total memory references.
              <pre><code class="cpp">for (size_t i = 0; i < n; ++i)
{
  b[i] = a[i] + 1.f;
  c[i] = b[i] / 2.f;
  d[i] = 1.f / c[i];
}
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>#8: Loop collapse</h2>
            <table class="simple">
              <colgroup>
                <col></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code class="cpp">
for (int j = 0; j &lt; height; j++)
{
  for (int i = 0; i &lt; width; i++)
  {
    if (img[j * width + i] &gt; 0)
    {
      count++;
    }
  }
}
                    </code></pre>
                  </td>
                  <td>
                    <pre><code class="cpp">
for (int j = 0; j &lt; height * width; j++)
{
  if (img[j] &gt; 0)
    count++;
}
                    </code></pre>
                  </td>
              </tbody>
            </table>
        </section>

        <section>
          <section>
            <h2>Auto-vectorization</h2>
            <ul>
              <li>Machine code generation that takes advantage of vector instructions.</li>
              <li>Most of all modern architectures have vector units (co-processors or specialized pipes)
                <ul>
                  <li>MMX, SSE, SSE2, SSE4, AVX, AVX-512</li>
                  <li>AltiVec, VSX</li>
                  <li>ASIMD (NEON), MSA</li>
                </ul>
              </li>
              <li>Enabled by inlining, unrolling, fusion, software pipelining, inter-procedural optimization, etc.</li>
            </ul>
          </section>
<!--           <section>
            <p>absdiff -03 or hand-written assembly</p>
          </section> -->
        </section>

        <section id="end1">
          <h1>THE END</h1>
          <img class="simple" src="images/popt/infinity.png">
          <h4><a href="https://github.com/cuda-geek">Marina Kolpakova</a> / 2015</h4s>
        </section>

      </div>

    </div>

    <script src="plugin/reveal/lib/js/head.min.js"></script>
    <script src="plugin/reveal/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: true,
        history: true,
        center: false,

        width: 960,
        height: 720,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'plugin/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
