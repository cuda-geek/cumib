<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Pragmatic optimization in modern programming - Demystifying the Compiler</title>
    <meta name="description" content="Pragmatic optimization in modern programming - Introduction">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="plugin/reveal/css/reveal.css">
    <link rel="stylesheet" href="plugin/reveal/css/theme/geek.css" id="theme">
    <link rel="stylesheet" href="css/colors-orange.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="plugin/reveal/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'plugin/reveal/css/print/pdf.css' : 'plugin/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

  <style type="text/css">
  .reveal .console {
    font-family:Courier;
    color: #CCCCCC;
    background: #000000;
  }
  </style>

    <!--[if lt IE 9]>
    <script src="plugin/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <h1>Pragmatic optimization</h1>
          <h2>in modern programming</h2>
          <h3>Demystifying the Compiler</h3>
          <br>
          <br>
          <br>
          <small>Created by
            <a href="http://github.com/cuda-geek">Marina Kolpakova</a>
            for
            <a href="http://www.unn.ru/eng/">UNN</a> / 2015
          </small>
        </section>

        <section>
          <h2>Course Topics</h2>
          <ul>
            <li><strong>Pragmatics</strong>
              <ul>
                <li>Ordering optimization approaches</b></li>
                <li><b>Demystifying a compiler</b></li>
                <li>Mastering compiler optimizations</li>
              </ul>
            </li>
            <br/>
            <li><strong>Computer Architectures</strong>
              <ul>
                <li>Architecture of modern computers</li>
                <li>SIMD extensions</li>
                <li>Specific co-processors</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2>Outline</h2>
          <ul>
            <li>Compilation trajectory</li>
            <li>Intermediate language</li>
            <li>Compiler optimization challenges
              <ul>
                <li>Pointer aliasing</li>
                <li>Functional calls</li>
                <li>Floating point math</li>
                <li>...</li>
              </ul>
            </li>
            <li>Optimization levels</li>
            <li>Case study: compiler flags</li>
            <li>compiler's feedback</li>
            <li>Link-time optimization</li>
            <li>Summary</li>
          </ul>
        </section>

        <section>
          <h2>Executable generation phases</h2>
          <ul>
            <li><b>Pre-processing.</b> Pre-process, but don't compile.
              <ul>
                <li><code class="console">gcc -E test.cc</code></li>
                <li><code class="console">cl /E test.cc</code></li>
              </ul>
            </li>
            <li><b>Compilation.</b> Compile, but don't assemble.
              <ul>
                <li><code class="console">gcc -S test.cc</code></li>
                <li><code class="console">cl /FA test.cc</code></li>
              </ul>
            </li>
            <li><b>Assembling.</b> Assemble, but don't link.
              <ul>
                <li><code class="console">gcc -c test.cc</code></li>
                <li><code class="console">cl /c test.cc</code></li>
              </ul>
            </li>
            <li><b>Linking.</b> Link object files to generate the executable.
              <ul>
                <li><code class="console">gcc test.cc</code></li>
                <li><code class="console">cl test.cc</code></li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Compilation trajectory</h2>
            <img class="simple" src="images/popt/compiler_phases.svg">
            <dl>
              <dt><b>Lexical Analysis</b></dt>
              <dd>scans the source code as a stream of characters converting it into lexemes (tokens).</dd><br>
              <dt><b>Syntax Analysis</b></dt>
              <dd>takes the tokens, produced by lexical analysis, as input and generates a syntax tree.
                Source code grammar (syntactical correctness) is checked here.</dd>
            </dl>
          </section>

          <section>
            <h2>Compilation trajectory</h2>
            <img class="simple" src="images/popt/compiler_phases.svg">
            <dl>
              <dt><b>Semantic Analysis</b></dt>
              <dd>checks whether the constructed syntax tree follows the language rules (including the type checking).</dd><br>
              <dt><b>Intermediate Code Generation</b></dt>
              <dd> builds a program representation for some abstract machine. It is in between the high-level language and the
                target machine language.</dd>
            </dl>
          </section>

          <section>
            <h2>Compilation trajectory</h2>
            <img class="simple" src="images/popt/compiler_phases.svg">
            <dl>
              <dt><b>Code Optimization</b></dt>
              <dd>does optimization of the intermediate code (eg, redundancy elimination).</dd><br>
              <dt><b>Code Generation</b></dt>
              <dd>takes an optimized representation of the intermediate code and maps it to the target machine language.</dd>
            </dl>
          </section>

          <section>
            <h2>Frontend and backend</h2>
            <img src="images/popt/front-back.svg" class="simple">
            <ul>
              <li>Only a <b>backend</b> is required for <b>new machine</b> support</li>
              <li>Only a <b>frontend</b> is required for <b>new language</b> support</li>
              <li>Most of optimizations resemble each other for all targets and could be applied in between frontend and backend</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Intermediate language</h2>
            <img src="images/popt/intermediate_code.svg" class="simple" width="60%">
            <p>Optimization techniques become much easier to conduct on the level of intermediate code.
            Modern compilers usually use 2 levels of intermediate representation (IR).</p>
          </section>

          <section>
            <h2>Intermediate language</h2>
            <dl>
              <dt><b>High Level IR</b></dt>
              <dd>is close to the source and can be easily generated from the source code. Some code optimizations
              are possible. It is not very suitable for target machine optimization.</dd>
              <dt><b>Low Level IR</b></dt>
              <dd>is close to the target machine and used for machine-dependent optimizations: register allocation,
              instruction selection, peephole optimization.</dd>
            </dl>
          </section>

          <section>
            <h2>Intermediate language</h2>
            <ul>
              <li><b>Language-specific</b> to be used for JIT compilation later:
                <ul>
                  <li>Java byte code; .NET CLI, NVIDIA PTX.</li>
                </ul>
              </li>
              <li><b>Language independent</b>, like three-(four-)address code (similar to a classic RISC ISA).</li>
            </ul>
            <pre><code class="cpp">a = b + c * d;</code></pre>
            <p>Three-Address Code (TAC)</p>
            <pre><code class="c">r1 =  c *  d;
r2 =  b + r1;
r3 = r2 + r1;
a  = r3</code></pre>
            <p>Here <strong>r<small>th</small></strong> is an abstract register.</p>
          </section>

          <section>
            <h2>Three-Address Code</h2>
            <ul>
              <li>Quadruples has four fields
                <table>
                  <colgroup>
                    <col></col>
                    <col></col>
                    <col></col>
                    <col></col>
                  </colgroup>
                  <thead>
                    <tr>
                      <th>Op</th>
                      <th>arg1</th>
                      <th>arg2</th>
                      <th>result</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>*</td>
                      <td>c</td>
                      <td>d</td>
                      <td>r1</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>b</td>
                      <td>r1</td>
                      <td>r2</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>r2</td>
                      <td>r1</td>
                      <td>r3</td>
                    </tr>
                    <tr>
                      <td>=</td>
                      <td>r3</td>
                      <td></td>
                      <td>a</td>
                    </tr>
                  </tbody>
                </table>
              </li>
              <br/>
              <li>Triples or Indirect triples have three fields
                <table>
                  <colgroup>
                    <col></col>
                    <col></col>
                    <col></col>
                  </colgroup>
                  <thead>
                    <tr>
                      <th>Op</th>
                      <th>arg1</th>
                      <th>arg2</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>*</td>
                      <td>c</td>
                      <td>d</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>b</td>
                      <td>(0)</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>(1)</td>
                      <td>(0)</td>
                    </tr>
                    <tr>
                      <td>=</td>
                      <td>(2)</td>
                      <td></td>
                    </tr>
                  </tbody>
                </table>
              </li>
            </ul>
          </section>

          <section>
            <h2>Intermediate language</h2>
            <p>Provides frontend independent code representation.</p>
            <dl>
              <dt><a href="https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html#GENERIC">GENERIC</a>
              and <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a></dt>
              <dd>GNU Compiler Collection<br>
                <div style="vertical-align:middle;" class="console">
                  <span>-fdump-tree-all-fdump-tree-optimized -fdump-tree-<abbr attr title="Static Single Assignment">ssa</abbr></span><br>
                  <span> -fdump-<abbr title="Register Transfer Language">rtl</abbr>-all</span>
                </div>
              </dd>
              <dt><a href="http://llvm.org/docs/LangRef.html">LLVM IL</a></dt>
              <dd>clang and other LLWM based compilers<br>
                <div  style="vertical-align:middle;" class="console">-emit-llvm</div>
              </dd>
              <dt>CIL (C Intermediate Language)</dt>
              <dd>Visual Studio cl.exe</dd>
            </dl>
          </section>
          <section>
            <h2>Intermediate language</h2>
            <pre class="console"><span>$ clang -Os -S -emit-llvm test.c -o test.ll
$ cat test.ll</span></pre>
            <p><pre><code class="cpp">uint32_t gray2rgba_v1(uint8_t c)
{
  return c + (c&lt;&lt;8) + (c&lt;&lt;16) + (c&lt;&lt;24);
}</code></pre></p>
            <p><pre><code class="scala">define i32 @gray2rgba_v1(i8 zeroext %c) #0 {
  %1 = zext i8 %c to i32
  %2 = mul i32 %1, 16843009
  ret i32 %2
}</code></pre></p>
          </section>

          <section>
            <h2>Local variables</h2>
            <p>Compiler don't care how many variables are used in code, register allocation is done after IR rotations.</p>
            <pre class="cpp"><code>for( ; j <= roi.width - 4; j += 4 )
{
    uchar t0 = tab[src[j]];
    uchar t1 = tab[src[j+1]];
    dst[j] = t0;
    dst[j+1] = t1;
    t0 = tab[src[j+2]];
    t1 = tab[src[j+3]];
    dst[j+2] = t0;
    dst[j+3] = t1;
}</code></pre>
          </section>

          <section>
            <h2>Local variables</h2>
            <pre class="cpp" style="font-size:0.4em;"><code>.lr.ph4:                                          ; preds = %0, %.lr.ph4
  %indvars.iv5 = phi i64 [ %indvars.iv.next6, %.lr.ph4 ], [ 0, %0 ]
  %6 = getelementptr inbounds i8* %src, i64 %indvars.iv5
  %7 = load i8* %6, align 1, !tbaa !1
  %8 = zext i8 %7 to i64
  %9 = getelementptr inbounds i8* %tab, i64 %8
  %10 = load i8* %9, align 1, !tbaa !1
  %11 = or i64 %indvars.iv5, 1
  %12 = getelementptr inbounds i8* %src, i64 %11
  %13 = load i8* %12, align 1, !tbaa !1
  %14 = zext i8 %13 to i64
  %15 = getelementptr inbounds i8* %tab, i64 %14
  %16 = load i8* %15, align 1, !tbaa !1
  %17 = getelementptr inbounds i8* %dst, i64 %indvars.iv5
  store i8 %10, i8* %17, align 1, !tbaa !1
  %18 = getelementptr inbounds i8* %dst, i64 %11
  store i8 %16, i8* %18, align 1, !tbaa !1
  %19 = or i64 %indvars.iv5, 2
  %20 = getelementptr inbounds i8* %src, i64 %19
  %21 = load i8* %20, align 1, !tbaa !1
  %22 = zext i8 %21 to i64
  %23 = getelementptr inbounds i8* %tab, i64 %22
  %24 = load i8* %23, align 1, !tbaa !1
  %25 = or i64 %indvars.iv5, 3
  %26 = getelementptr inbounds i8* %src, i64 %25
  %27 = load i8* %26, align 1, !tbaa !1
  %28 = zext i8 %27 to i64
  %29 = getelementptr inbounds i8* %tab, i64 %28
  %30 = load i8* %29, align 1, !tbaa !1
  %31 = getelementptr inbounds i8* %dst, i64 %19
  store i8 %24, i8* %31, align 1, !tbaa !1
  %32 = getelementptr inbounds i8* %dst, i64 %25
  store i8 %30, i8* %32, align 1, !tbaa !1
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 4
  %33 = trunc i64 %indvars.iv.next6 to i32
  %34 = icmp sgt i32 %33, %1
  br i1 %34, label %..preheader_crit_edge, label %.lr.ph4
</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Pointer aliasing</h2>
            <p><pre><code class="cpp">void twiddle1(int *xp, int *yp)
{
    *xp += *yp;
    *xp += *yp;
}</code></pre></p>
            <p><pre><code class="cpp">void twiddle2(int *xp, int *yp)
{
    *xp += 2* *yp;
}</code></pre></p>
            <h3>Are they always equal?</h3>
          </section>

          <section>
            <h2>Pointer aliasing</h2>
            <p>What if..</p>
            <p><pre><code class="cpp">int main(int argc, char** argv)
{
    int i = 5, j = 5;
    twiddle1(&amp;i, &amp;i);
    twiddle2(&amp;j, &amp;j);

    printf("twiddle1 result is %d\n", i);
    printf("twiddle2 result is %d\n", j);
}</code></pre></p>
          <p>twiddle1 result is 20 while twiddle2 result is 15</p>
          </section>

          <section>
            <h2>Pointer aliasing</h2>
            <blockquote>
               <b>Aliasing</b>
               refers to the situation where the same memory location can be accessed by using different names.
            </blockquote>
            <p><pre><code class="cpp">void twiddle1(int *xp, int *yp)
{
    *xp += *yp;
    *xp += *yp;
}</code></pre></p>
            <p><pre><code class="cpp">void twiddle2(int *xp, int *yp)
{
    *xp += 2* *yp;
}</code></pre></p>
          </section>

          <section>
            <h2>Strict aliasing assumption</h2>
            <blockquote><b>Strict aliasing</b> is an assumption, made by a C (or C++) compiler, that dereferencing
            pointers to objects of different types will never refer to the same memory location.</blockquote>
            <p>This assumption enables more aggressive optimization (gcc assumes it up from -02), but a programmer
            should have to follow strict aliasing rules to get code working correctly.</p>
          </section>
          <section>
            <h2>Strict aliasing assumption</h2>
            <pre><code class="cpp">void check(int32_t *h, int64_t *k)
{
  *h = 5; *k = 6;
  printf("%d\n", *h);
}
void main()
{
  int64_t k;
  check((int32_t *)&k, &k);
}</code></pre>
          <p><span class="console">gcc -O1 test.c -o test ; ./test</span> results in <b>6</b>
          <span class="console">gcc -O2 test.c -o test ; ./test</span> results in <b>5</b></p>
          </section>

          <section>
            <h2>Pointer aliasing: missed opportunities</h2>
            <ul>
              <li>Compiler freely schedules arithmetic,<br/>but often preserves the order of memory dereferencing</li>
              <li>Compiler is limited in redundancy elimination</li>
              <li>Compiler is limited in loop unrolling</li>
              <li>Compiler is limited in auto-vectorization</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Function calls</h2>
            <pre><code class="cpp">int callee();
int caller()
{
  return callee() + callee();
}</code></pre>
            <p><pre><code class="cpp">int callee();
int caller()
{
  return 2*callee();
}</code></pre></p>
            <h3>Are they equal?</h3>
          </section>

          <section>
            <h2>Function calls</h2>
              <table style="width:100%;" class="simple">
                <colgroup>
                  <col></col>
                  <col></col>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
                      <pre><code class="cpp">int callee(int i);
int caller()
{
  int s=0, i=0;
  for (; i&lt;N; i++)
    s += callee(i);

  return s;
}


</code></pre>
                    </td>
                    <td>
                      <pre><code class="cpp">int callee(int i);
int caller()
{
  int s0=0, s1=0, i=0;
  for (; i&lt;N/2; i+=2)
  {
    s0 += callee(i);
    s1 += callee(i+1);
  }
  return s0 + s1;
}</code></pre>
                    </td>
                  </tr>
                </tbody>
              </table><br/>
            <h3>Are they equal?</h3>
          </section>


          <section>
            <h2>Pure functions</h2>
            <blockquote><b>Pure function</b> is a function for which both of the following statements are true:
              <ol>
                <li>The function always evaluates the same result having been given the same argument value(s).
                The function result must not depend on any hidden information or state that may change while program
                execution proceeds or between different executions of the program, as well as on any external input
                from I/O devices.</li>
                <li>Evaluation of the result does not cause any semantically observable side effect or output,
                such as mutation of mutable objects or output to I/O devices.
                </li>
              </ol>
            </blockquote>
          </section>
          <section>
            <h2>Pure functions</h2>
            <ul>
              <li>Pure functions are much easier to optimize. Expressing ideas in code as pure functions simplifies
              compiler's life.</li>
              <li>Most functions from math.h are not pure (sets/cleans floating point flags and conditions, throws
              floating point exceptions)</li>
              <li>Use <b>constexpr</b> keyword for c++11 to hint a compiler that function could be evaluated in compile time</li>
              <li>Use <b>static</b> keyword to help the compiler to see all the usages of the function
              (and perform aggressive inlining, or even deduce whether the function is pure or not)</li>
              <li><strong>Neither constexpr nor static doesn't guarantee that function is pure</strong>
              but they give compiler some hints.</li>
            </ul>
          </section>

          <section>
            <h2>Functional calls: missed opportunities</h2>
            <blockquote>Inlining the function is replacing the function call with the body of the called function.</blockquote>
            <p>If the compiler fails to inline a function body:</p>
            <ul>
              <li>it is limited in redundancy elimination</li>
              <li>there are some overhead on function calls</li>
              <li>inlining is crucial for functional calls from loops</li>
              <li>many other optimizations aren't performed for this fragment of code
                <ul>
                  <li>loop unrolling</li>
                  <li>auto-vectorization</li>
                  <li>etc</li>
                </ul>
              </li>
              <li>potential bloating of code and stack</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Floating point</h2>
            <ul>
              <li>Floating point arithmetics is not associative<br>, so <b>A+(B+C) != (A+B)+C</b></li>
              <li>A compiler is very conservative about floating point!</li>
            </ul>
            <pre><code class="cpp">void associativityCheck (void)
{
  double x = 3.1415926535897931;
  double a = 1.0e15;
  double b = -(1.0e15 - 1.0);
  printf("%f %f\n", x*(a + b), x*a + x*b );
}</code></pre>
          <p><pre class="console"><span>$ gcc check.c -o check ; ./check
3.141593 3.000000</span></pre></p>
            <p>Such situation is known as <b>catastrophic cancellation</b> </p>
          </section>
        </section>

        <section>
          <h2>More optimization challenges</h2>
          <ul>
            <li>Branches inside a loop</li>
            <li>Exceptions</li>
            <li>Accesses to storage type global variables</li>
            <li>Inline assembly</li>
            <li><code>volatile</code> keyword</li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Optimization levels</h2>
            <dl>
              <dt><b>-O0</b> (the default) No optimization</dt>
              <dd>generates unoptimized code but has the fastest compilation time.</dd>
              <dt><b>-O1</b> Moderate optimization</dt>
              <dd>optimizes reasonably well but does not degrade compilation time significantly.</dd>
              <dt><b>-O2</b> Full optimization</dt>
              <dd>generates highly optimized code and has the slowest compilation time.</dd>
              <dt><b>-O3</b> Aggressive optimization</dt>
              <dd>employees more aggressive automatic inlining of subprograms within a unit and attempts to vectorize.</dd>
              <dt><b>-Os</b> Optimize space usage</dt>
            </dl>
          </section>

          <section>
          <h2>enabled optimizations: GCC -O3 </h2>
          <p>GNU C version 4.9.2 (x86_64-linux-gnu)<br/>
          <code style="background-color:black;">$ touch 1.c; gcc -O3 -S -fverbose-asm 1.c</code>
          <blockquote style="font-size: 0.5em">
options enabled:
-faggressive-loop-optimizations
-fasynchronous-unwind-tables
-fauto-inc-dec
-fbranch-count-reg
-fcaller-saves
-fcombine-stack-adjustments
-fcommon
-fcompare-elim
-fcprop-registers
-fcrossjumping
-fcse-follow-jumps
-fdefer-pop
-fdelete-null-pointer-checks
-fdevirtualize
-fdevirtualize-speculatively
-fdwarf2-cfi-asm
-fearly-inlining
-feliminate-unused-debug-types
-fexpensive-optimizations
-fforward-propagate
-ffunction-cse
-fgcse
-fgcse-after-reload
-fgcse-lm
-fgnu-runtime
-fgnu-unique
-fguess-branch-probability
-fhoist-adjacent-loads
-fident
-fif-conversion
-fif-conversion2
-findirect-inlining
-finline
-finline-atomics
-finline-functions
-finline-functions-called-once
-finline-small-functions
-fipa-cp
-fipa-cp-clone
-fipa-profile
-fipa-pure-const
-fipa-reference
-fipa-sra
-fira-hoist-pressure
-fira-share-save-slots
-fira-share-spill-slots
-fisolate-erroneous-paths-dereference
-fivopts
-fkeep-static-consts
-fleading-underscore
-fmath-errno
-fmerge-constants
-fmerge-debug-strings
-fmove-loop-invariants
-fomit-frame-pointer
-foptimize-sibling-calls
-foptimize-strlen
-fpartial-inlining
-fpeephole
-fpeephole2
-fpredictive-commoning
-fprefetch-loop-arrays
-free
-freg-struct-return
-freorder-blocks
-freorder-blocks-and-partition
-freorder-functions
-frerun-cse-after-loop
-fsched-critical-path-heuristic
-fsched-dep-count-heuristic
-fsched-group-heuristic
-fsched-interblock
-fsched-last-insn-heuristic
-fsched-rank-heuristic
-fsched-spec
-fsched-spec-insn-heuristic
-fsched-stalled-insns-dep
-fschedule-insns2
-fshow-column
-fshrink-wrap
-fsigned-zeros
-fsplit-ivs-in-unroller
-fsplit-wide-types
-fstack-protector
-fstrict-aliasing
-fstrict-overflow
-fstrict-volatile-bitfields
-fsync-libcalls
-fthread-jumps
-ftoplevel-reorder
-ftrapping-math
-ftree-bit-ccp
-ftree-builtin-call-dce
-ftree-ccp -ftree-ch
-ftree-coalesce-vars
-ftree-copy-prop
-ftree-copyrename
-ftree-cselim
-ftree-dce
-ftree-dominator-opts
-ftree-dse
-ftree-forwprop
-ftree-fre
-ftree-loop-distribute-patterns
-ftree-loop-if-convert
-ftree-loop-im
-ftree-loop-ivcanon
-ftree-loop-optimize
-ftree-loop-vectorize
-ftree-parallelize-loops=
-ftree-partial-pre
-ftree-phiprop
-ftree-pre
-ftree-pta
-ftree-reassoc
-ftree-scev-cprop
-ftree-sink
-ftree-slp-vectorize
-ftree-slsr
-ftree-sra
-ftree-switch-conversion
-ftree-tail-merge
-ftree-ter
-ftree-vrp
-funit-at-a-time
-funswitch-loops
-funwind-tables
-fverbose-asm
-fzero-initialized-in-bss
-m128bit-long-double
-m64
-m80387
-malign-stringops
-mavx256-split-unaligned-load
-mavx256-split-unaligned-store
-mfancy-math-387
-mfp-ret-in-387
-mfxsr
-mglibc
-mieee-fp
-mlong-double-80
-mmmx
-mno-sse4
-mpush-args
-mred-zone
-msse
-msse2
-mtls-direct-seg-refs
-mvzeroupper
              </blockquote></p>
          </section>

          <section>
            <h2>Example: floating point</h2>
            <pre><code class="cpp">double power( double d, unsigned n)
{
  double x = 1.0;
  for (unsigned j = 1; j<=n; j++, x *= d) ;
  return x;
}
int main ()
{
  double a = 1./0x80000000U, sum = 0.0;
  for (unsigned i=1; i<= 0x80000000U; i++)
    sum += power( i*a, i % 8);
  printf ("sum = %g\n", sum);
}</code></pre>
            <small style="float:right;">
              <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-dp-c">flags-dp.c</a>
            </small>
          </section>

          <section>
            <h2>Example: floating point</h2>
            <ol>
              <li>Compile it <b>without</b> optimization
                <pre class="console"><span>$ gcc -std=c99 -Wall -O0 flags-dp.c -o flags-dp
$ time ./flags-dp
sum = 7.29569e+08
real  0m24.550s</span></pre></li><br/>
              <li>Compile it with <b>the first</b> optimization level: <b>~3.26 speedup</b>
                <pre class="console"><span>$ gcc -std=c99 -Wall -O1 flags-dp.c -o flags-dp
$ time ./flags-dp</code></strong>
sum = 7.29569e+08
real  0m7.529s</span></pre></li>
            </ol>
          </section>

          <section>
            <h2>Example: floating point</h2>
            <ol start="3">
              <li>Compile it with <b>the second</b> optimization level: <b>~1.24 speedup</b>
                <pre class="console"><span>$ gcc -std=c99 -Wall -O2 flags-dp.c -o flags-dp
$ time ./flags-dp
sum = 7.29569e+08
real  0m6.069s</span></pre></li><br/>
              <li>Compile it with <b>the third</b> optimization level:  <b>~1.00 speedup</b>
                <pre class="console"><span>$ gcc -std=c99 -Wall -O3 flags-dp.c -o flags-dp
$ time ./flags-dp</code></strong>
sum = 7.29569e+08
real  0m6.067s</span></pre></li>
            </ol>
            <p><b>Total speedup is ~4.05</b></p>
          </section>

          <section>
            <h2>Example: integer</h2>
            <pre><code class="cpp">int power( int d, unsigned n)
{
  int x = 1;
  for (unsigned j = 1; j<=n; j++, x*=d) ;
  return x;
}
int main ()
{
  int64_t sum = 0;
  for (unsigned i=1; i<0x80000000U; i++)
    sum += power( i, i % 8);
  printf ("sum = %ld\n", sum);
}</code></pre>
            <small style="float:right;">
              <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-c">flags.c</a>
            </small>
          </section>

          <section>
            <h2>Example: integer</h2>
            <ol style="width:100%">
              <li>Compile it <b>without</b> optimization
                <pre class="console"><span>$ gcc -std=c99 -Wall -O0 flags.c -o flags
$ time ./flags
sum = 288231861405089791
real  0m18.750s</span></pre></li><br/>
              <li>Compile it with <b>the first</b> optimization level: <b>~2.64 speedup</b>
                <pre class="console"><span>$ gcc -std=c99 -Wall -O1 flag.c -o flags
$ time ./flags</code></strong>
sum = 288231861405089791
real  0m7.092s</span></pre></li>
            </ol>
          </section>

          <section>
            <h2>Example: integer</h2>
            <ol start="3" style="width:100%">
              <li>Compile it with <b>the second</b> optimization level:<b>~0.97 speedup</b>
                <pre class="console"><span>$ gcc -std=c99 -Wall -O2 flags.c -o flags
$ time ./flags
sum = 288231861405089791
real  0m7.300s</span></pre></li><br/>
              <li>Compile it with <b>the third</b> optimization level:  <b>~1.00 speedup</b>
                <pre class="console"><span>$ gcc -std=c99 -Wall -O3 flags.c -o flags
$ time ./flags</code></strong>
sum = 288231861405089791
real  0m7.082s</span></pre></li>
            </ol>
            <h3>What there is no improvement?</h3>
          </section>

          <section>
            <h2>Example: integer</h2>
            <table style="width:100%; font-size:0.6em;" class="simple">
              <colgroup>
                <col style="width:33%;"></col>
                <col style="width:33%;"></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td style="border-right: 3px double #F0E7D5;">Optimization level: -O1
                    <pre><code class="x86asm">  movl  $1, %r8d
  movl  $0, %edx
.L9:
  movl  %r8d, %edi
  movl  %r8d, %esi
  andl  $7, %esi
  je  .L10
  movl  $1, %ecx
  movl  $1, %eax
.L8:                @
  addl  $1, %eax    @
  imull %edi, %ecx  @
  cmpl  %eax, %esi  @
  jae .L8
  jmp .L7
.L10:
  movl  $1, %ecx
.L7:
  movslq  %ecx, %rcx
  addq  %rcx, %rdx
  addl  $1, %r8d
  jns .L9
  @ printing is here</code></pre>
                  </td>
                  <td>Optimization level: -O2
                    <pre><code class="x86asm">  movl    $1, %esi
    movl    $1, %r8d
    xorl    %edx, %edx
    .p2align 4,,10
    .p2align 3
.L10:
    movl    %r8d, %edi
    andl    $7, %edi
    je  .L11
    movl    $1, %ecx
    movl    $1, %eax
    .p2align 4,,10
    .p2align 3
.L9:
    addl    $1, %eax
    imull   %esi, %ecx
    cmpl    %eax, %edi
    jae .L9
    movslq  %ecx, %rcx</code></pre>
                  </td>
                  <td><br/>
                    <pre><code class="x86asm">.L8:
    addl    $1, %r8d
    addq    %rcx, %rdx
    testl   %r8d, %r8d
    movl    %r8d, %esi
    jns .L10
    subq    $8, %rsp
    @ printing is here
    ret
.L11:
    movl    $1, %ecx
    jmp .L8</code></pre>
                  <br>
                  <h3>Compiler overdone with branch twiddling and alignment</h3>
                  </td>
                </tr>
              </tbody>
            </table>

          </section>

          <section>
            <h2>Helping a compiler</h2>
            <blockquote>Compiler usually applies optimization to the inner loops. In this example number of iterations in the inner
            loop depends on a value of an induction variable of the outer loop.</blockquote>
            <p> Let's help the compiler (
            <small style="vertical-align:middle;">
              <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-dp-tuned-c">flags-dp-tuned.c</a>
            </small>)</p>
            <p><pre class="console"><span>$ gcc -std=c99 -Wall -O3 flags-dp-tuned.c\
-o flags-dp-tuned
$ time ./flags-dp-tuned</code></strong>
sum = 7.29569e+08
real  0m2.448s</span></pre>
            <b>Speedup is ~2.48x.</b>
            </p>
          </section>
          <section>
            <h2>Helping a compiler</h2>
            <pre><code class="cpp" style="font-size:0.9em;line-height: 0.9em;">/*power function is not changed*/
int main ()
{
  double a = 1./0x80000000U, s = -1.;
  for (double i=0; i<=0x80000000U-8; i += 8)
  {
    s+=power((i+0)*a,0);s+=power((i+1)*a,1);
    s+=power((i+2)*a,2);s+=power((i+3)*a,3);
    s+=power((i+4)*a,4);s+=power((i+5)*a,5);
    s+=power((i+6)*a,6);s+=power((i+7)*a,7);
  }
  printf ("sum = %g\n", s);
}</code></pre>
          </section>

          <section>
            <h2>Helping a compiler</h2>
            <p>Let's try it for integers (
              <small style="vertical-align:middle;">
                <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-tuned-c">flags-tuned.c</a>
              </small>)
            </p>
            <pre><code class="cpp" style="font-size:0.9em;line-height: 0.9em;">/*power function is not changed*/
int main ()
{
  int64_t sum = -1;
  for (unsigned i=0; i<=0x80000000U-8; i += 8)
  {
    sum+=power(i+0, 0); sum+=power(i+1,1);
    sum+=power(i+2, 2); sum+=power(i+3,3);
    sum+=power(i+4, 4); sum+=power(i+5,5);
    sum+=power(i+6, 6); sum+=power(i+7,7);
  }
  printf ("sum = %ld\n", sum);
}</code></pre>
          </section>

          <section>
            <h2>Helping a compiler</h2>
            <p><pre class="console"><span>$ gcc -std=c99 -Wall -O3 flags-tuned.c\
-o flags-tuned
$ time ./flags-tuned</code></strong>
sum = 288231861405089791
real  0m1.286s</span></pre>
            <b>Speedup is ~5.5x.</b>
            </p>
          </section>
        </section>

        <section>
          <section>
            <h2>How to get a feedback?</h2>
            <ul>
              <li><b>Check wall-time of you application</b>
                <ul>
                <li>If a compiler has done its job well, you'll see performance improvements</li>
                </ul>
              </li>
              <br>
              <li><b>Dump an assembly of your code</b> (or/and IL)
                <ul>
                  <li>Ensure instruction and register scheduling</li>
                  <li>Check for extra operations and register spills</li>
                </ul>
              </li>
              <br>
              <li><b>See compiler optimization report</b>
                <ul>
                  <li>All the compilers have some support for it</li>
                  <li>Some of them are able to generate very detailed reports
                  about loop unrolling, auto-vectorization, VLIW slots scheduling, etc</li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h2>Example: GCC feedback options</h2>
            <ul>
              <li>Enables optimization information printing
              <strong><pre><div class="console">-fopt-info</div></strong></pre>
              <pre><div class="console">-fopt-info-&lt;optimized/missed/note/all&gt;</div></pre>
              <pre><div class="console">-fopt-info-all-&lt;ipa/loop/inline/vec/optall&gt;</div></pre>
              <pre><div class="console">-fopt-info=filename</div></pre>
              </li>
              <li>Controls the amount of debugging output the scheduler prints on targets
              that use instruction scheduling
              <pre><div class="console">-fopt-info -fsched-verbose=n</div></pre>
              </li>
              <li>Controls the amount of output from auto-vectorizer
              <pre><div class="console">-ftree-vectorizer-verbose=n </div></pre></li>
            </ul>
          </section>

          <section>
            <h2>Examples: GCC feedback options</h2>
            <ul style="width:100%;">
              <li>Outputs all optimization info to stderr.
                <pre><div class="console">gcc -O3 -fopt-info</div></pre>
              </li>
              <li>Outputs missed optimization report from all the passes to missed.txt
                <pre><div class="console">gcc -O3 -fopt-info-missed=missed.txt</div></pre>
              </li>
              <li>Outputs information about missed optimizations as well as optimized locations from all the inlining
              passes to inline.txt.
                <pre><div class="console" style="font-size:0.85em;">gcc -O3 -fopt-info-inline-optimized-missed=inline.txt</div></pre>
              </li>
            </ul>
          </section>

          <section>
            <h2>GCC feedback example</h2>
            <pre class="console" style="font-size:0.5em;"><span>./src/box.cc:193:9: note: loop <b>vectorized</b>
./src/box.cc:193:9: note: loop <b>versioned</b> for vectorization because of possible aliasing
./src/box.cc:193:9: note: loop peeled for vectorization to enhance alignment
./src/box.cc:96:9: note: loop vectorized
./src/box.cc:96:9: note: loop <b>peeled</b> for vectorization to enhance alignment
./src/box.cc:51:9: note: loop vectorized
./src/box.cc:51:9: note: loop peeled for vectorization to enhance alignment
./src/box.cc:193:9: note: loop with 7 iterations <b>completely unrolled</b>
./src/box.cc:32:13: note: loop with 7 iterations completely unrolled
./src/box.cc:96:9: note: loop with 15 iterations completely unrolled
./src/box.cc:51:9: note: loop with 15 iterations completely unrolled
./src/box.cc:584:9: note: loop vectorized
./src/box.cc:584:9: note: loop versioned for vectorization because of possible aliasing
./src/box.cc:584:9: note: loop peeled for vectorization to enhance alignment
./src/box.cc:482:9: note: loop vectorized
./src/box.cc:482:9: note: loop peeled for vectorization to enhance alignment
./src/box.cc:463:5: note: loop vectorized
./src/box.cc:463:5: note: loop versioned for vectorization because of possible aliasing
./src/box.cc:463:5: note: loop peeled for vectorization to enhance alignment</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Link-Time Optimization (LTO)</h2>
            <p>Perform inter-procedural optimizations during linking.</p>
            <img class="simple" src="images/popt/lto.svg"/>
            <p>Most compilers support this feature:
              <ul>
                <li><strong><a href="http://llvm.org/docs/LinkTimeOptimization.html">clang</a></strong> (-flto)</li>
                <li><strong><a href="https://gcc.gnu.org/onlinedocs/gccint/LTO-Overview.html">gcc</a></strong>
                 (-flto) stating with 4.9</li>
                <li><strong><a href="https://msdn.microsoft.com/en-us/library/0zza0de8.aspx">cl.exe</a></strong> (/GL, /LTCG)</li>
                <li>...</li>
              </ul>
            </p>
          </section>

          <section>
            <h2>WHOPR: Whole program optimization</h2>
            <ol>
              <li>Compile each source file separately, add extra information to the object file</li>
              <li>Analyze information collected from all object files</li>
              <li>Perform second optimization phase to generate object file</li>
              <li>Link the final binary</li>
            </ol>
            <img class="simple" src="images/popt/wpo.svg">
            <ul>
              <li>Eliminate even more redundant code</li>
              <li>Compilations is better optimized for multi-core systems</li>
            </ul>
          </section>
        </section>

        <section>
          <h2>Summary: Toward a compiler</h2>
          <ul>
            <li><b>Correctness takes precedence over performance</b></li>
            <li>For typical constructs a compiler will usually do better job than a programmer</li>
            <li>A compiler is not aware of your program semantics</li>
            <li>Compiler optimization is a multi-phase iterative process</li>
            <li>Performing one optimization allows many other</li>
            <li>Most optimizations need certain order of application</li>
            <br/>
            <li>Learn a compiler well and stick to it</li>
            <li>Express your intentions to the compiler clearly</li>
            <li>Check for a compiler feedback</li>
            <li><b>Write pure code!</b></li>
          </ul>
        </section>

        <section id="end1">
          <h1>THE END</h1>
          <img class="simple" src="images/popt/infinity.png">
          <h4><a href="https://github.com/cuda-geek">Marina Kolpakova</a> / 2015</h4s>
        </section>

      </div>
    </div>

    <script src="plugin/reveal/lib/js/head.min.js"></script>
    <script src="plugin/reveal/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: true,
        history: true,
        center: false,

        width: 960,
        height: 720,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'plugin/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
