<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Pragmatic optimization in modern programming</title>
    <meta name="description" content="Pragmatic optimization in modern programming - Introduction">
    <meta name="author" content="Marina Kolpakova (cuda.geek)">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="plugin/reveal/css/reveal.css">
    <link rel="stylesheet" href="plugin/reveal/css/theme/geek.css" id="theme">
    <link rel="stylesheet" href="css/colors-orange.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="plugin/reveal/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'plugin/reveal/css/print/pdf.css' : 'plugin/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="plugin/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <section>
          <h1>Pragmatic optimization</h1>
          <h2>in modern programming</h2>
          <h3>Demystifying the Compiler</h3>
          <br>
          <br>
          <br>
          <small>Created by
            <a href="http://github.com/cuda-geek">Marina Kolpakova</a>
            for
            <a href="http://www.unn.ru/eng/">UNN</a>
          </small>
        </section>

        <section>
          <h2>Outline</h2>
          <ul>
            <li>Compilation trajectory</li>
            <li>Intermediate language</li>
            <li>Compiler optimizations obstacles
              <ul>
                <li>Pointer aliasing</li>
                <li>Functional calls</li>
                <li>Floating point math</li>
              </ul>
            </li>
            <li>Optimization levels</li>
            <li>Optimization feedback</li>
            <li>Summary</li>
          </ul>
        </section>

        <section>
          <h2>Executable generation phases</h2>
          <ul>
            <li><b>Pre-processing.</b> Pre-process, but don't compile.
              <ul>
                <li><strong><code>gcc -E test.cc</code></strong></li>
                <li><strong><code>cl /E test.cc</code></strong></li>
              </ul>
            </li>
            <li><b>Compilation</b> Compile, but don't assemble.
              <ul>
                <li><strong><code>gcc -S test.cc</code></strong></li>
                <li><strong><code>cl /FA test.cc</code></strong></li>
              </ul>
            </li>
            <li><b>Assembly.</b> Assemble, but don't link.
              <ul>
                <li><strong><code>gcc -c test.cc</code></strong></li>
                <li><strong><code>cl /c test.cc</code></strong></li>
              </ul>
            </li>
            <li><b>Linking.</b> Link object files to generate the executable.
              <ul>
                <li><strong><code>gcc test.cc</code></strong></li>
                <li><strong><code>cl test.cc</code></strong></li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Compilation trajectory</h2>
            <img class="simple" src="images/popt/compiler_phases.svg">
            <br/><br/>
            <dl>
              <dt><b>Lexical Analysis</b></dt>
              <dd>scans the source code as a stream of characters &amp; converts it into lexemes (tokens).</dd>
              <dt><b>Syntax Analysis</b></dt>
              <dd>takes the token produced by lexical analysis as input and generates a syntax tree.
                Source code grammar (syntactical correctness) is checked here.</dd>
              <dt><b>Semantic Analysis</b></dt>
              <dd>checks whether the syntax tree constructed follows the rules of language (eg, type checks).</dd>
            </dl>
          </section>

          <section>
            <h2>Compilation trajectory</h2>
            <img class="simple" src="images/popt/compiler_phases.svg">
            <br/><br/>
            <dl>
              <dt><b>Intermediate Code Generation</b></dt>
              <dd>represents a program for some abstract machine. It is in between the high-level language and the
                machine language.</dd>
              <dt><b>Code Optimization</b></dt>
              <dd>does code optimization of the intermediate code (eg, redundancy elimination).</dd>
              <dt><b>Code Generation</b></dt>
              <dd>takes the optimized representation of the intermediate code and maps it to the target machine language.</dd>
            </dl>
          </section>

          <section>
            <h2>Frontend and backend</h2>
            <img src="images/popt/front-back.svg" class="simple">
            <ul>
              <li>No requirement for a full native compiler for each new target or programming language</li>
              <li>Only backend part needed to support every new machine</li>
              <li>Only frontend part needed to support every new programming language</li>
              <li>Most of optimization resemble for all targets and could be applied in between font end and backend.</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Intermediate language</h2>
            <img src="images/popt/intermediate_code.svg" class="simple" width="60%">
            <p>It becomes easier to apply code optimization techniques on the intermediate code. Modern compiler usually
            use 2 levels of intermediate representation (IR).</p>
            <dl>
              <dt><b>High Level IR</b></dt>
              <dd>is close to the source and can be easily generated from the source code. Some code optimizations
              are possible, is less preferred for target machine optimization.</dd>
              <dt><b>Low Level IR</b></dt>
              <dd>is close to the target machine and suitable for register allocation, instruction selection, peephole,
              etc, is used for machine-dependent optimizations.</dd>
            </dl>
          </section>

<!-- Intermediate code generator receives input from its predecessor phase, semantic analyzer,
in the form of an annotated syntax tree. That syntax tree then can be converted into a linear
representation, e.g., postfix notation. Intermediate code tends to be machine independent code.
Therefore, code generator assumes to have unlimited number of memory storage (register) to generate code. -->

          <section>
            <h2>Intermediate language</h2>
            <ul>
              <li>Language-specific: it can be used for JIT compilation later:
                <ul>
                  <li>Java, Scala bute code; CLI for .NET languages like C#, F#, PTX for GPU shaders.</li>
                </ul>
              </li>
              <li>language independent like three-address code (similar to classic RISC ISA).</li>
            </ul>
            <pre style="width:50%"><code class="cpp">a = b + c * d;</code></pre>
            <p>Three-Address Code (TAC)</p>
            <pre style="width:50%"><code>r1 = c * d;
r2 = b + r1;
r3 = r2 + r1;
a = r3</code></pre>
            <p>Here <strong>r1, r2</strong>, etc are as abstract registers.</p>
          </section>

          <section>
            <h2>Three-Address Code</h2>
            <ul>
              <li>Quadruples has four fields: operator, arg1, arg2, and result
                <table>
                  <colgroup>
                    <col></col>
                    <col></col>
                    <col></col>
                    <col></col>
                  </colgroup>
                  <thead>
                    <tr>
                      <th>Op</th>
                      <th>arg1</th>
                      <th>arg2</th>
                      <th>result</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>*</td>
                      <td>c</td>
                      <td>d</td>
                      <td>r1</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>b</td>
                      <td>r1</td>
                      <td>r2</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>r2</td>
                      <td>r1</td>
                      <td>r3</td>
                    </tr>
                    <tr>
                      <td>=</td>
                      <td>r3</td>
                      <td></td>
                      <td>a</td>
                    </tr>
                  </tbody>
                </table>
              </li>
              <br/>
              <li>Triples or Indirect triples has three fields : op, arg1, and arg2.
                <table>
                  <colgroup>
                    <col></col>
                    <col></col>
                    <col></col>
                  </colgroup>
                  <thead>
                    <tr>
                      <th>Op</th>
                      <th>arg1</th>
                      <th>arg2</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>*</td>
                      <td>c</td>
                      <td>d</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>b</td>
                      <td>(0)</td>
                    </tr>
                    <tr>
                      <td>+</td>
                      <td>(1)</td>
                      <td>(0)</td>
                    </tr>
                    <tr>
                      <td>=</td>
                      <td>(2)</td>
                      <td></td>
                    </tr>
                  </tbody>
                </table>
              </li>
            </ul>
          </section>

          <section>
            <h2>Intermediate language</h2>
            <p>Provide font-end independent code representation.</p>
            <dl>
              <dt><a href="https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html#GENERIC">GENERIC</a>
              and <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a></dt>
              <dd>GNU Compiler Collection gcc
                <small style="vertical-align:middle;">(
                  <code>-fdump-tree-all -fdump-tree-ssa -fdump-tree-optimized -fdump-rtl-all</code>)
                </small>
              </dd>
              <dt><a href="http://llvm.org/docs/LangRef.html">LLWM IL</a></dt>
              <dd>clang and other LLWM based compilers <small  style="vertical-align:middle;">(
                <code>-emit-llvm</code>)
                </small>
              </dd>
              <dt>CIL (C Intermediate Language)</dt>
              <dd>Visual Studio cl.exe</dd>
            </dl>
            <blockquote>
              clang -Os -S -emit-llvm squere.c -o squere.ll; cat squere.ll
            </blockquote>
            <table style="width:100%;" class="simple">
              <colgroup>
                <col style="width:50%;"></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code class="cpp">int square(int a)
{
  return a*a;
}</code></pre>
                  </td>
                  <td>
                    <pre><code>define i32 @square(i32 %a) #0 {
%1 = mul nsw i32 %a, %a
ret i32 %1
}</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>

        <section>
          <section>
            <h2>Optimization obstacles: pointer aliasing</h2>
              <table style="width:100%;"  class="simple">
                <colgroup>
                  <col style="width:50%;"></col>
                  <col></col>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
                      <pre><code class="cpp">
  void twiddle1(int *xp, int *yp)
  {
      *xp += *yp;
      *xp += *yp;
  }
                      </code></pre>
                    </td>
                    <td>
                      <pre><code class="cpp">
  void twiddle2(int *xp, int *yp)
  {
      *xp += 2* *yp;
  }
                      </code></pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            <h3>Are they equal?</h3>
          </section>

          <section>
            <h2>Optimization obstacles: pointer aliasing</h2>
              <table style="width:100%;"  class="simple">
                <colgroup>
                  <col style="width:50%;"></col>
                  <col></col>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
                      <pre><code class="cpp">
  void twiddle1(int *xp, int *yp)
  {
      *xp += *yp;
      *xp += *yp;
  }
                      </code></pre>
                    </td>
                    <td>
                      <pre><code class="cpp">
  void twiddle2(int *xp, int *yp)
  {
      *xp += 2* *yp;
  }
                      </code></pre>
                    </td>
                  </tr>
                </tbody>
              </table>
              <pre style="width:50%"><code class="cpp">
int main(int argc, char** argv)
{
    int i = 5, j = 5;

    twiddle1(&i, &i);
    twiddle2(&j, &j);

    printf("twiddle1 result is %d\n", i);
    printf("twiddle2 result is %d\n", j);
}
            </code></pre>
          <p><code>
twiddle1 result is 20<br/>
twiddle2 result is 15

          </code></p>
          </section>

          <section>
            <h2>Optimization obstacles: pointer aliasing</h2>
              <table style="width:100%;" class="simple">
                <colgroup>
                  <col style="width:50%;"></col>
                  <col></col>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
                      <pre><code class="cpp">
void twiddle(int *xp, int *yp)
{
    *xp += *yp;
    *xp += *yp;
}
                      </code></pre>
                    </td>
                    <td>
                      <pre><code class="cpp">
void twiddle(int *xp, int *yp)
{
    *xp += 2* *yp;
}
                      </code></pre>
                    </td>
                  </tr>
                </tbody>
              </table>
              <blockquote>
                 <b>Aliasing</b>
                 refers to the situation where the same memory location can be accessed by using different names.
              </blockquote>
          </section>

          <section>
            <h2>Strict aliasing assumption</h2>
            <p>Strict aliasing is an assumption, made by a C (or C++) compiler, that dereferencing pointers to objects
            of different types will never refer to the same memory location.</p>
            <p>This assumption enables much more optimization, but a programmer should follow strict aliasing rules
            to get code working correctly.</p>
            <pre><code class="cpp">void check(int32_t *h, int64_t *k)
{
  *h = 5;
  *k = 6;
  printf("%d\n", *h);
}

int main (void)
{
  int64_t k;
  check((int32_t *)&k, &k);
  return 0;

}</code></pre>
          <p><code style="background-color:black;">gcc -O1 test.c -o test ; ./test</code> results in <b>6</b></p>
          <p><code style="background-color:black;">gcc -O2 test.c -o test ; ./test</code> results in <b>5</b></p>
          </section>

          <section>
            <h2>Pointer aliasing: missed opportunities</h2>
            <ul>
              <li>Compiler freely schedule arithmetic,<br/>but preserves order of memory dereferencing</li>
              <li>Compiler is limited in redundancy elimination</li>
              <li>Compiler is limited in loop unrolling</li>
              <li>Compiler is limited in auto-vectorization</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Optimization obstacles: functional calls</h2>
              <table style="width:100%;" class="simple">
                <colgroup>
                  <col style="width:50%;"></col>
                  <col></col>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
                      <pre><code class="cpp">
int callee();

int caller()
{
  return callee() + callee();
}
                      </code></pre>
                    </td>
                    <td>
                      <pre><code class="cpp">
int callee();

int caller()
{
  return 2*callee();
}
                      </code></pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            <h3>Are they equal?</h3>
          </section>

          <section>
            <h2>Optimization obstacles: functional calls</h2>
              <table style="width:100%;" class="simple">
                <colgroup>
                  <col style="width:50%;"></col>
                  <col></col>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
                      <pre><code class="cpp">
int callee(int i);

int caller()
{
  int sum = 0;
  for (int i = 0; i < 1000; i++)
  {
    sum += callee(i);
  }

  return sum;
}
                      </code></pre>
                    </td>
                    <td>
                      <pre><code class="cpp">
int callee(int i);

int caller()
{
  int sum0 = 0, sum1 = 0;
  for (int i = 0; i < 500; i+= 2)
  {
    sum0 += callee(i);
    sum1 += callee(i+1);
  }

  return sum0 + sum1;
}
                      </code></pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            <h3>Are they equal?</h3>
          </section>


          <section>
            <h2>Pure functions</h2>
            <dl>
              <dt><b>Pure function</b></dt>
              <dd>is a function for which both of the following statements are true:
                <ul>
                  <li>The function always evaluates the same result value given the same argument value(s). The function
                  result value cannot depend on any hidden information or state that may change while program execution
                  proceeds or between different executions of the program, nor can it depend on any external input
                  from I/O devices.</li>
                  <li>Evaluation of the result does not cause any semantically observable side effect or output,
                  such as mutation of mutable objects or output to I/O devices.
                  </li>
                </ul>
              </dd>
            </dl>
            <p>Pure functions are much easy to optimize:</p>
            <ul>
              <li>Use <b>static</b> keyword to help the compiler to deduce whether the function is pure</li>
              <li>Use <b>constexpr</b> keyword for c++11 to hint a compiler that function could be evaluated in compile time</li>
              <li>Most functions from math.h are not pure.</li>
            </ul>
          </section>

          <section>
            <h2>Functional calls: missed opportunities</h2>
            <p>Inlining the function body is replacing a subroutine call with the code from the original function.
            Inlining is crucial for functional calls from loops.</p>
            <p>If a compiler failed to inline a function body:</p>
            <ul>
              <li>it is limited in redundancy elimination</li>
              <li>there are some overhead on function calls</li>
              <li>many other optimizations
                <ul>
                  <li>loop unrolling</li>
                  <li>auto-vectorization</li>
                  <li>etc</li>
                </ul>
              </li>
              <li>potential bloating of code and stack</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Optimization obstacles: Floating point math</h2>
            <ul>
              <li>Compiler much more conservative on floating point rather than integer math.</li>
              <li>Floating point arithmetics is not associative so <b>A+(B+C) != (A+B)+C</b></li>
            </ul>
            <pre><code class="cpp">
void associativityCheck (void)
{
  double x = 3.1415926535897931;
  double a = 1.0e15;
  double b = -(1.0e15 - 1.0);

  printf("%f %f\n", x*(a + b), x*a + x*b );
}
</code></pre>
          <pre><code>
$ gcc check.c -o check ; ./check
3.141593 3.000000

</code></pre>
          </section>
<!--           <section>
            <h2>Optimization obstacles: Floating point math</h2>
          </section> -->
        </section>

        <section>
          <h2>More optimization obstacles</h2>
          <ul>
            <li>Branches inside a loop</li>
            <li>Exceptions</li>
            <li>Accesses to storage type global variables</li>
            <li>Inline assembly</li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Optimization levels</h2>
            <dl>
              <dt><b>-O0</b> (the default)</dt>
              <dd>No optimization; generates unoptimized code but has the fastest compilation time.</dd>
              <dt><b>-O1</b></dt>
              <dd>Moderate optimization; optimizes reasonably well but does not degrade compilation time significantly.</dd>
              <dt><b>-O2</b></dt>
              <dd>Full optimization; generates highly optimized code and has the slowest compilation time.</dd>
              <dt><b>-O3</b></dt>
              <dd>Full optimization as in `-O2'; also uses more aggressive automatic inlining of subprograms within a unit
                (Inlining of Subprograms) and attempts to vectorize loops.</dd>
              <dt><b>-Os</b></dt>
              <dd>Optimize space usage (code and data) of resulting program.</dd>
            </dl>
          </section>

          <section>
          <h2>enabled optimizations: GCC -O3 </h2>
          <p>GNU C (Ubuntu 4.9.2-0ubuntu1~14.04) version 4.9.2 (x86_64-linux-gnu)</p>
          <pre style="width:70%;"><code class="bash"> touch empty.c && gcc -O3 -S -fverbose-asm empty.c</code></pre>
            <small>
              <blockquote>
options enabled:
-faggressive-loop-optimizations
-fasynchronous-unwind-tables
-fauto-inc-dec
-fbranch-count-reg
-fcaller-saves
-fcombine-stack-adjustments
-fcommon
-fcompare-elim
-fcprop-registers
-fcrossjumping
-fcse-follow-jumps
-fdefer-pop
-fdelete-null-pointer-checks
-fdevirtualize
-fdevirtualize-speculatively
-fdwarf2-cfi-asm
-fearly-inlining
-feliminate-unused-debug-types
-fexpensive-optimizations
-fforward-propagate
-ffunction-cse
-fgcse
-fgcse-after-reload
-fgcse-lm
-fgnu-runtime
-fgnu-unique
-fguess-branch-probability
-fhoist-adjacent-loads
-fident
-fif-conversion
-fif-conversion2
-findirect-inlining
-finline
-finline-atomics
-finline-functions
-finline-functions-called-once
-finline-small-functions
-fipa-cp
-fipa-cp-clone
-fipa-profile
-fipa-pure-const
-fipa-reference
-fipa-sra
-fira-hoist-pressure
-fira-share-save-slots
-fira-share-spill-slots
-fisolate-erroneous-paths-dereference
-fivopts
-fkeep-static-consts
-fleading-underscore
-fmath-errno
-fmerge-constants
-fmerge-debug-strings
-fmove-loop-invariants
-fomit-frame-pointer
-foptimize-sibling-calls
-foptimize-strlen
-fpartial-inlining
-fpeephole
-fpeephole2
-fpredictive-commoning
-fprefetch-loop-arrays
-free
-freg-struct-return
-freorder-blocks
-freorder-blocks-and-partition
-freorder-functions
-frerun-cse-after-loop
-fsched-critical-path-heuristic
-fsched-dep-count-heuristic
-fsched-group-heuristic
-fsched-interblock
-fsched-last-insn-heuristic
-fsched-rank-heuristic
-fsched-spec
-fsched-spec-insn-heuristic
-fsched-stalled-insns-dep
-fschedule-insns2
-fshow-column
-fshrink-wrap
-fsigned-zeros
-fsplit-ivs-in-unroller
-fsplit-wide-types
-fstack-protector
-fstrict-aliasing
-fstrict-overflow
-fstrict-volatile-bitfields
-fsync-libcalls
-fthread-jumps
-ftoplevel-reorder
-ftrapping-math
-ftree-bit-ccp
-ftree-builtin-call-dce
-ftree-ccp -ftree-ch
-ftree-coalesce-vars
-ftree-copy-prop
-ftree-copyrename
-ftree-cselim
-ftree-dce
-ftree-dominator-opts
-ftree-dse
-ftree-forwprop
-ftree-fre
-ftree-loop-distribute-patterns
-ftree-loop-if-convert
-ftree-loop-im
-ftree-loop-ivcanon
-ftree-loop-optimize
-ftree-loop-vectorize
-ftree-parallelize-loops=
-ftree-partial-pre
-ftree-phiprop
-ftree-pre
-ftree-pta
-ftree-reassoc
-ftree-scev-cprop
-ftree-sink
-ftree-slp-vectorize
-ftree-slsr
-ftree-sra
-ftree-switch-conversion
-ftree-tail-merge
-ftree-ter
-ftree-vrp
-funit-at-a-time
-funswitch-loops
-funwind-tables
-fverbose-asm
-fzero-initialized-in-bss
-m128bit-long-double
-m64
-m80387
-malign-stringops
-mavx256-split-unaligned-load
-mavx256-split-unaligned-store
-mfancy-math-387
-mfp-ret-in-387
-mfxsr
-mglibc
-mieee-fp
-mlong-double-80
-mmmx
-mno-sse4
-mpush-args
-mred-zone
-msse
-msse2
-mtls-direct-seg-refs
-mvzeroupper
              </blockquote>
            </small>
          </section>

          <section>
            <h2>Optimization levels example: floating point</h2>
            <table style="width:100%;" class="simple">
              <colgroup>
                <col style="width:50%;"></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code style="padding-left:2em;" class="cpp">#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

double power (double d, unsigned n)
{
  double x = 1.0;
  unsigned j;

  for (j = 1; j <= n; j++)
    x *= d;

  return x;
}</code></pre>
                  </td>
                  <td>
                    <pre><code class="cpp" style="padding-left:2em;">int main (void)
{
  double sum = 0.0;
  unsigned i;

  for (i = 1; i <= INT_MAX; i++)
  {
    sum += power(i, i % 8);
  }

  printf ("sum = %g\n", sum);
  return 0;
}</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <p>Compile it <b>without</b> optimization:<br/>
              <strong><code>gcc -Wall -O0 test.c -o test-flags-dp && time ./test-flags-dp</code></strong>
            </p>
            <pre style="width:30%"><code class="bash">sum = 7.06739e+72
real  0m23.229s</code></pre>
          </section>

          <section>
            <h2>Optimization levels example: floating point</h2>
            <ul>
              <li>
                <p>Compile it with <b>the first</b> optimization level: <b>~2.78 speedup</b><br/>
                  <strong><code>gcc -Wall -O1 test.c -o test-flags-dp && time ./test-flags-dp</code></strong>
                </p>
                <pre style="width:30%"><code class="bash">sum = 7.06739e+72
real  0m8.342s</code></pre>
              </li>
              <li>
                <p>Compile it with <b>the second</b> optimization level: <b>~1.55 speedup</b><br/>
                  <strong><code>gcc -Wall -O2 test.c -o test-flags-dp && time ./test-flags-dp</code></strong>
                </p>
                <pre style="width:30%"><code class="bash">sum = 7.06739e+72
real  0m5.371s</code></pre>
              </li>
              <li>
                <p>Compile it with <b>the third</b> optimization level:  <b>~1.025 speedup</b><br/>
                  <strong><code>gcc -Wall -O3 test.c -o test-flags-dp && time ./test-flags-dp</code></strong>
                </p>
                <pre style="width:30%"><code class="bash">sum = 7.06739e+72
real  0m5.240s</code></pre>
              </li>
              <li><b>Total speedup is ~4.43</b></li>
            </ul>
          </section>

          <section>
            <h2>Optimization levels example: integer</h2>
            <table style="width:100%;" class="simple">
              <colgroup>
                <col style="width:50%;"></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code style="padding-left:2em;" class="cpp">#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int power(int d, unsigned n)
{
  int x = 1;
  unsigned j;

  for (j = 1; j <= n; j++)
    x *= d;

  return x;
}</code></pre>
                  </td>
                  <td>
                    <pre><code class="cpp" style="padding-left:2em;">int main()
{
  int sum = 0.0;
  unsigned i = 1;

  for (; i <= INT_MAX-8; i++)
  {
    sum += power(i, i % 8);
  }

  printf ("sum = %d\n", sum);
  return 0;
}</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <p>Compile it w/o optimization:</p>
            <p><strong><code>gcc -Wall -O0  test.c -o test-flags && time ./test-flags</code></strong></p>
            <pre style="width:30%"><code class="bash">sum = -805306349
real  0m19.025s
</code></pre>
          </section>

          <section>
            <h2>Optimization levels example: integer</h2>
            <ul>
              <li>
                <p>Compile it with <b>the first</b> optimization level: <b>~2.92 speedup</b><br/>
                  <strong><code>gcc -Wall -O1 test.c -o test-flags && time ./test-flags</code></strong>
                </p>
                <pre style="width:30%"><code class="bash">sum = -805306349
real  0m6.526s
</code></pre>
              </li>
              <li>
                <p>Compile it with <b>the second</b> optimization level: <b>~0.93 speedup</b><br/>
                  <strong><code>gcc -Wall -O2 test.c -o test-flags && time ./test-flags</code></strong>
                </p>
                <pre style="width:30%"><code class="bash">sum = -805306349
real  0m6.950s</code></pre>
              </li>
              <li>
                <p>Compile it with <b>the third</b> optimization level:  <b>~1.00 speedup</b><br/>
                  <strong><code>gcc -Wall -O3 test.c -o test-flags && time ./test-flags</code></strong>
                </p>
                <pre style="width:30%"><code class="bash">sum = -805306349
real  0m6.918s
</code></pre>
              </li>
              <li><h3>What causes performance degradation?</h3></li>
            </ul>
          </section>

          <section>
            <h2>Optimization levels example: integer</h2>
            <table style="width:100%;" class="simple">
              <colgroup>
                <col style="width:33%;"></col>
                <col style="width:33%;"></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td style="border-right: 3px double #F0E7D5;">
                    <pre><code style="padding-left:2em;" class="x86asm">  movl  $1, %r8d
  movl  $0, %edx
.L4:
  movl  %r8d, %edi
  movl  %r8d, %esi
  andl  $7, %esi
  je  .L5
  movl  $1, %eax
  movl  $1, %ecx
.L3:
  imull %edi, %ecx
  addl  $1, %eax
  cmpl  %eax, %esi
  jae .L3
  jmp .L2
.L5:
  movl  $1, %ecx
.L2:
  addl  %ecx, %edx
  addl  $1, %r8d
  jns .L4</code></pre>
                  </td>
                  <td>
                    <pre><code class="x86asm" style="padding-left:2em;">  movl  $1, %esi
  movl  $1, %r8d
  xorl  %edx, %edx
  .p2align 4,,10
  .p2align 3
.L4:
  movl  %r8d, %edi
  andl  $7, %edi
  je  .L5
  movl  $1, %eax
  movl  $1, %ecx
  .p2align 4,,10
  .p2align 3
.L3:
  addl  $1, %eax
  imull %esi, %ecx
  cmpl  %eax, %edi
  jae .L3</code></pre>
                  </td>
                  <td>
                    <pre><code class="x86asm" style="padding-left:2em;">addl  $1, %r8d
  addl  %ecx, %edx
  testl %r8d, %r8d
  movl  %r8d, %esi
  jns .L4
.L10:
@ printing is here
.L5:
  addl  $1, %r8d
  movl  $1, %ecx
  addl  %ecx, %edx
  testl %r8d, %r8d
  movl  %r8d, %esi
  jns .L4
  jmp .L10</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <p>Compiler overdone unrolling of other loop</p>
          </section>

          <section>
            <h2>Optimization: helping a compiler</h2>
            <p>Compiler usually apples optimization to inner loops. In this example number of iterations in inner
            loop depends on number loop induction variable
            of outer loop. Let's help the compiler</p>
            <pre><code class="cpp">int main (void)
{
  double sum = 0.0;
  unsigned i;

  for (i = 1; i <= INT_MAX-8; i += 8)
  {
    sum += power(i+0, 0);
    sum += power(i+1, 1);
    sum += power(i+2, 2);
    sum += power(i+3, 3);
    sum += power(i+4, 4);
    sum += power(i+5, 5);
    sum += power(i+6, 6);
    sum += power(i+7, 7);
  }

  printf ("sum = %g\n", sum);
  return 0;
}</code></pre>
            <p>
              <strong><code>gcc -Wall -O3 test.c -o test-flags-dp && time ./test-flags-dp</code></strong>
              <b>Speedup is ~3.16x.</b>
            </p>
            <pre style="width:30%"><code class="bash">sum = 7.06739e+72
real  0m1.660s</code></pre>
          </section>

          <section>
            <h2>Optimization: helping a compiler</h2>
            <p>Let's try it for integers</p>
            <pre><code class="cpp">int main (void)
{
  int sum = -1;
  unsigned i;

  for (i = 0; i <= INT_MAX-8-8; i += 8)
  {
    sum += power(i+0, 0);
    sum += power(i+1, 1);
    sum += power(i+2, 2);
    sum += power(i+3, 3);
    sum += power(i+4, 4);
    sum += power(i+5, 5);
    sum += power(i+6, 6);
    sum += power(i+7, 7);
  }

  printf ("sum = %g\n", sum);
  return 0;
}</code></pre>
            <p>
              <strong><code>gcc -Wall -O3 test.c -o test-flags && time ./test-flags</code></strong>
              <b>Speedup is ~5.14x.</b>
            </p>
            <pre style="width:30%"><code class="bash">sum = -805306349
real  0m1.269s</code></pre>
          </section>

        </section>

        <section>
          <section>
            <h2>How to get a feedback?</h2>
            <ul style="width:80%">
              <li><b>Check wall-time of you application</b>
                <ul>
                <li>If a compiler did its job well, you'll see performance improvements</li>
                </ul>
              </li>
              <br>
              <li><b>Dump an assembly of your code</b> (or/and intermediate language)
                <ul>
                  <li>Ensure instruction and register scheduling</li>
                  <li>Check for extra operations and register spills.</li>
                </ul>
              </li>
              <br>
              <li><b>See compiler optimization report</b>
                <ul>
                  <li>All the compilers have some support for it</li>
                  <li>Some of them are able to generate very detailed reports
                  about loop unrolling, auto-vectorization, VLIW slots scheduling, etc</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>GCC feedback options</h2>
            <ul>
              <li><strong>-fopt-info</strong></li>
              <li>-fopt-info-options</li>
              <li>-fopt-info-options=filename</li>
              <li>-fopt-info -fsched-verbose=n</li>
              <li>-ftree-vectorizer-verbose=n (analogy to icc -vec-report)</li>
            </ul>
<!--     ‘optimized’
        Print information when an optimization is successfully applied. It is up to a pass to decide which information is relevant. For example, the vectorizer passes print the source location of loops which got successfully vectorized.
    ‘missed’
        Print information about missed optimizations. Individual passes control which information to include in the output. For example,

                       gcc -O2 -ftree-vectorize -fopt-info-vec-missed

        will print information about missed optimization opportunities from vectorization passes on stderr.
    ‘note’
        Print verbose information about optimizations, such as certain transformations, more detailed messages about decisions etc.
    ‘all’
        Print detailed optimization information. This includes optimized, missed, and note.

    The second set of options describes a group of optimizations and may include one or more of the following.

    ‘ipa’
        Enable dumps from all interprocedural optimizations.
    ‘loop’
        Enable dumps from all loop optimizations.
    ‘inline’
        Enable dumps from all inlining optimizations.
    ‘vec’
        Enable dumps from all vectorization optimizations.
    ‘optall’
        Enable dumps from all optimizations. This is a superset of the optimization groups listed above. -->
          </section>
          <section>
            <h2>GCC feedback example</h2>
            <pre><code class="bash">
  ./src/box.cc:193:9: note: loop vectorized
  ./src/box.cc:193:9: note: loop versioned for vectorization because of possible aliasing
  ./src/box.cc:193:9: note: loop peeled for vectorization to enhance alignment
  ./src/box.cc:96:9: note: loop vectorized
  ./src/box.cc:96:9: note: loop peeled for vectorization to enhance alignment
  ./src/box.cc:51:9: note: loop vectorized
  ./src/box.cc:51:9: note: loop peeled for vectorization to enhance alignment
  ./src/box.cc:193:9: note: loop with 7 iterations completely unrolled
  ./src/box.cc:32:13: note: loop with 7 iterations completely unrolled
  ./src/box.cc:96:9: note: loop with 15 iterations completely unrolled
  ./src/box.cc:51:9: note: loop with 15 iterations completely unrolled
  ./src/box.cc:584:9: note: loop vectorized
  ./src/box.cc:584:9: note: loop versioned for vectorization because of possible aliasing
  ./src/box.cc:584:9: note: loop peeled for vectorization to enhance alignment
  ./src/box.cc:482:9: note: loop vectorized
  ./src/box.cc:482:9: note: loop peeled for vectorization to enhance alignment
  ./src/box.cc:463:5: note: loop vectorized
  ./src/box.cc:463:5: note: loop versioned for vectorization because of possible aliasing
  ./src/box.cc:463:5: note: loop peeled for vectorization to enhance alignment</code></pre>
          </section>
        </section>

        <section>
          <h2>Link-Time Code Generation</h2>
          When LTCG is enabled (by specifying the /GL compiler switch), the compiler driver (cl.exe)
          <!-- C Inter­mediate Language (CIL) -->
           GCC 4.8 feature a few improvements when it comes to LTO, a.k.a. Link-Time Optimization
           <!-- https://gcc.gnu.org/onlinedocs/gccint/LTO-Overview.html -->
           <!-- http://gcc-python-plugin.readthedocs.org/en/latest/lto.html -->
        </section>

        <section>
          <h2>Summary: Toward a compiler</h2>
          <ul>
            <li>Correctness is always emphasized over performance</li>
            <li>For typical constructs a compiler will usually does better job than a programmer</li>
            <li>A compiler is not aware of your program semantics</li>
            <li>Compiler optimization is a multi-phase iterative process</li>
            <li>Performing one optimization enables a compiler to perform other ones </li>
            <li>Most optimizations need to be applied to code in order</li>
            <br/>
            <li>Learn a compiler well and stick to it</li>
            <li>Express your intentions to the compiler clearly</li>
            <li>Check for a compiler feedback</li>
          </ul>
        </section>

        <section id="end1">
          <h1>THE END</h1>
          <img class="simple" src="images/popt/infinity.png">
          <h4><a href="https://github.com/cuda-geek">Marina Kolpakova</a> / 2015</h4s>
        </section>

      </div>
    </div>

    <script src="plugin/reveal/lib/js/head.min.js"></script>
    <script src="plugin/reveal/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: true,
        history: true,
        center: false,

        width: 960,
        height: 720,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'plugin/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
